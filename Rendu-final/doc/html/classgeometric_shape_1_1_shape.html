<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tangram: Référence de la classe geometricShape::Shape</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="titre.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tangram
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegeometric_shape.html">geometricShape</a></li><li class="navelem"><a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Fonctions membres publiques</a> &#124;
<a href="#pro-methods">Fonctions membres protégées</a> &#124;
<a href="#pro-attribs">Attributs protégés</a> &#124;
<a href="#pri-attribs">Attributs privés</a> &#124;
<a href="#friends">Amis</a> &#124;
<a href="classgeometric_shape_1_1_shape-members.html">Liste de tous les membres</a>  </div>
  <div class="headertitle">
<div class="title">Référence de la classe geometricShape::Shape</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a>.  
 <a href="classgeometric_shape_1_1_shape.html#details">Plus de détails...</a></p>

<p><code>#include &lt;<a class="el" href="shape_8hpp_source.html">shape.hpp</a>&gt;</code></p>
<div class="dynheader">
Graphe d'héritage de geometricShape::Shape:</div>
<div class="dyncontent">
<div class="center"><img src="classgeometric_shape_1_1_shape__inherit__graph.png" border="0" usemap="#geometric_shape_1_1_shape_inherit__map" alt="Inheritance graph"/></div>
<map name="geometric_shape_1_1_shape_inherit__map" id="geometric_shape_1_1_shape_inherit__map">
<area shape="rect" id="node2" href="classgeometric_shape_1_1_parallelogram.html" title="Classe représentant le parallelogram. " alt="" coords="5,468,208,619"/>
<area shape="rect" id="node3" href="classgeometric_shape_1_1_rigth_triangle.html" title="Classe répresentant le triangle. " alt="" coords="233,475,434,611"/>
<area shape="rect" id="node4" href="classgeometric_shape_1_1_square.html" title="Classe représentant un carré. " alt="" coords="459,475,624,611"/>
</map>
</div>
<div class="dynheader">
Graphe de collaboration de geometricShape::Shape:</div>
<div class="dyncontent">
<div class="center"><img src="classgeometric_shape_1_1_shape__coll__graph.png" border="0" usemap="#geometric_shape_1_1_shape_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Fonctions membres publiques</h2></td></tr>
<tr class="memitem:aa45bec6f55f33a59991f83a1d0843a53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#aa45bec6f55f33a59991f83a1d0843a53">Shape</a> (double <a class="el" href="classgeometric_shape_1_1_shape.html#a1fbc9b3cdfcf2170ef9e1c6aaf86402c">sizeCote</a>, int width, int height)</td></tr>
<tr class="memdesc:aa45bec6f55f33a59991f83a1d0843a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur de la class <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a>.  <a href="#aa45bec6f55f33a59991f83a1d0843a53">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa45bec6f55f33a59991f83a1d0843a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4470674c16e4a7058554d473aa5fbf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a4e4470674c16e4a7058554d473aa5fbf">~Shape</a> ()</td></tr>
<tr class="memdesc:a4e4470674c16e4a7058554d473aa5fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructeur de la class <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a>.  <a href="#a4e4470674c16e4a7058554d473aa5fbf">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4e4470674c16e4a7058554d473aa5fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad141f6bc47907a6f19825430fc3638e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#ad141f6bc47907a6f19825430fc3638e2">Shape</a> (const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;cshape)</td></tr>
<tr class="memdesc:ad141f6bc47907a6f19825430fc3638e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur de copie.  <a href="#ad141f6bc47907a6f19825430fc3638e2">Plus de détails...</a><br /></td></tr>
<tr class="separator:ad141f6bc47907a6f19825430fc3638e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5e79f1181e8284aca3323c56135cd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#aef5e79f1181e8284aca3323c56135cd6">operator=</a> (const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;cshape)</td></tr>
<tr class="memdesc:aef5e79f1181e8284aca3323c56135cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opérateur de copie.  <a href="#aef5e79f1181e8284aca3323c56135cd6">Plus de détails...</a><br /></td></tr>
<tr class="separator:aef5e79f1181e8284aca3323c56135cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20194d8e1bd7a66d64e7874341498a72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a20194d8e1bd7a66d64e7874341498a72">operator==</a> (const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;cshape) const</td></tr>
<tr class="memdesc:a20194d8e1bd7a66d64e7874341498a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surcharge de l'opérateur de comparaison pour une figure.  <a href="#a20194d8e1bd7a66d64e7874341498a72">Plus de détails...</a><br /></td></tr>
<tr class="separator:a20194d8e1bd7a66d64e7874341498a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c25b597e4a88d0a5d099efd3dfab9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a56c25b597e4a88d0a5d099efd3dfab9d">moveShape</a> (int &amp;xInside, int &amp;yInside, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;fig, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;motif, MLV_Color motifShape, MLV_Color motifBorder, std::list&lt; MLV_Color &gt; &amp;colorfig, std::list&lt; MLV_Color &gt;::iterator fig_num, <a class="el" href="class_board.html">Board</a> &amp;board, bool &amp;wincondi)</td></tr>
<tr class="memdesc:a56c25b597e4a88d0a5d099efd3dfab9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode permettant de géré les events utilisateur et les rotation/translation des figures.  <a href="#a56c25b597e4a88d0a5d099efd3dfab9d">Plus de détails...</a><br /></td></tr>
<tr class="separator:a56c25b597e4a88d0a5d099efd3dfab9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16cafaabf0742f54f718ba319c1afee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#ae16cafaabf0742f54f718ba319c1afee">draw</a> (MLV_Color colorShape, MLV_Color colorBorder=MLV_COLOR_BLACK) const</td></tr>
<tr class="memdesc:ae16cafaabf0742f54f718ba319c1afee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode permettant desinner une figure de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a>.  <a href="#ae16cafaabf0742f54f718ba319c1afee">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae16cafaabf0742f54f718ba319c1afee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af666bd629db0595afa79982548b6cf78"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#af666bd629db0595afa79982548b6cf78">display</a> (std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:af666bd629db0595afa79982548b6cf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode permettant d'afficher sur la console l'objet souhaité.  <a href="#af666bd629db0595afa79982548b6cf78">Plus de détails...</a><br /></td></tr>
<tr class="separator:af666bd629db0595afa79982548b6cf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10713940996e923488745dfa7dbe1c46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a10713940996e923488745dfa7dbe1c46">isInside</a> (const int &amp;x, const int &amp;y) const</td></tr>
<tr class="memdesc:a10713940996e923488745dfa7dbe1c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode permettant de regardé sur un clique de la souris est compris dans un objet.  <a href="#a10713940996e923488745dfa7dbe1c46">Plus de détails...</a><br /></td></tr>
<tr class="separator:a10713940996e923488745dfa7dbe1c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3890a8bbed0312d75df063615ef1a6d9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a3890a8bbed0312d75df063615ef1a6d9">reverse</a> ()</td></tr>
<tr class="memdesc:a3890a8bbed0312d75df063615ef1a6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode permettant de faire la symétrie d'un objet.  <a href="#a3890a8bbed0312d75df063615ef1a6d9">Plus de détails...</a><br /></td></tr>
<tr class="separator:a3890a8bbed0312d75df063615ef1a6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b2ed849b4838b665bc46fcd924bdf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a54b2ed849b4838b665bc46fcd924bdf2">rotateHW</a> (int angle, unsigned int n)</td></tr>
<tr class="memdesc:a54b2ed849b4838b665bc46fcd924bdf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode permettant de faire la rotation d'un objet par rapport à l'un de ses sommets.  <a href="#a54b2ed849b4838b665bc46fcd924bdf2">Plus de détails...</a><br /></td></tr>
<tr class="separator:a54b2ed849b4838b665bc46fcd924bdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393d5df22049c7c5efcab5f96a2d9018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a393d5df22049c7c5efcab5f96a2d9018">setShape</a> (std::vector&lt; double &gt; &amp;pXnew, std::vector&lt; double &gt; &amp;pYnew, std::vector&lt; double &gt; &amp;cnew, double &amp;scnew)</td></tr>
<tr class="memdesc:a393d5df22049c7c5efcab5f96a2d9018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seter de la class <a class="el" href="namespacegeometric_shape.html" title="Espace de nommage geometricShape regroupant les différentes classes de figures utilisées. ">geometricShape</a>.  <a href="#a393d5df22049c7c5efcab5f96a2d9018">Plus de détails...</a><br /></td></tr>
<tr class="separator:a393d5df22049c7c5efcab5f96a2d9018"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Fonctions membres protégées</h2></td></tr>
<tr class="memitem:af20eddd3fa1bf6ec35f9ed942c21d488"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#af20eddd3fa1bf6ec35f9ed942c21d488">getSizeCote</a> () const</td></tr>
<tr class="memdesc:af20eddd3fa1bf6ec35f9ed942c21d488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geter pour sizeCote de la class <a class="el" href="namespacegeometric_shape.html" title="Espace de nommage geometricShape regroupant les différentes classes de figures utilisées. ">geometricShape</a>.  <a href="#af20eddd3fa1bf6ec35f9ed942c21d488">Plus de détails...</a><br /></td></tr>
<tr class="separator:af20eddd3fa1bf6ec35f9ed942c21d488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9ef6bc53c00e40d8be8d46709d57ad"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a9e9ef6bc53c00e40d8be8d46709d57ad">getPx</a> () const</td></tr>
<tr class="memdesc:a9e9ef6bc53c00e40d8be8d46709d57ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geter pour px la class <a class="el" href="namespacegeometric_shape.html" title="Espace de nommage geometricShape regroupant les différentes classes de figures utilisées. ">geometricShape</a>.  <a href="#a9e9ef6bc53c00e40d8be8d46709d57ad">Plus de détails...</a><br /></td></tr>
<tr class="separator:a9e9ef6bc53c00e40d8be8d46709d57ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2191b95552288e73c4b7b4852b063d12"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a2191b95552288e73c4b7b4852b063d12">getPy</a> () const</td></tr>
<tr class="memdesc:a2191b95552288e73c4b7b4852b063d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geter pour py de la class <a class="el" href="namespacegeometric_shape.html" title="Espace de nommage geometricShape regroupant les différentes classes de figures utilisées. ">geometricShape</a>.  <a href="#a2191b95552288e73c4b7b4852b063d12">Plus de détails...</a><br /></td></tr>
<tr class="separator:a2191b95552288e73c4b7b4852b063d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22dac66031a0b7e87615d8402891d90"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#aa22dac66031a0b7e87615d8402891d90">getCenter</a> () const</td></tr>
<tr class="memdesc:aa22dac66031a0b7e87615d8402891d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geter pour center la class <a class="el" href="namespacegeometric_shape.html" title="Espace de nommage geometricShape regroupant les différentes classes de figures utilisées. ">geometricShape</a>.  <a href="#aa22dac66031a0b7e87615d8402891d90">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa22dac66031a0b7e87615d8402891d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c958faaa126d4190304be1acf3328b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a2c958faaa126d4190304be1acf3328b9">rotateCenter</a> (int angle, int x=0, int y=0, int x0=0, int y0=0)</td></tr>
<tr class="memdesc:a2c958faaa126d4190304be1acf3328b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode permettant de faire la rotation d'un objet par rapport à son centre.  <a href="#a2c958faaa126d4190304be1acf3328b9">Plus de détails...</a><br /></td></tr>
<tr class="separator:a2c958faaa126d4190304be1acf3328b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30aff4a795bcfff9f65353cf79d0376f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a30aff4a795bcfff9f65353cf79d0376f">translate</a> (int x, int y)</td></tr>
<tr class="memdesc:a30aff4a795bcfff9f65353cf79d0376f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode permettant de faire la translation d'un objet.  <a href="#a30aff4a795bcfff9f65353cf79d0376f">Plus de détails...</a><br /></td></tr>
<tr class="separator:a30aff4a795bcfff9f65353cf79d0376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b52ac575add3225201f29d5b81647f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a4b52ac575add3225201f29d5b81647f8">operator()</a> (int x, int y)</td></tr>
<tr class="memdesc:a4b52ac575add3225201f29d5b81647f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Foncteur de la méthode translate qui réalise donc la translation d'un objet.  <a href="#a4b52ac575add3225201f29d5b81647f8">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4b52ac575add3225201f29d5b81647f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2882c1c1968a92bdccd568f08a9c1d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#af2882c1c1968a92bdccd568f08a9c1d1">magnetisme</a> (const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;s2)</td></tr>
<tr class="memdesc:af2882c1c1968a92bdccd568f08a9c1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test si deux objets peuvent être magnétisé.  <a href="#af2882c1c1968a92bdccd568f08a9c1d1">Plus de détails...</a><br /></td></tr>
<tr class="separator:af2882c1c1968a92bdccd568f08a9c1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Attributs protégés</h2></td></tr>
<tr class="memitem:a34812f582bdf0a89b0d7e9a0b86dddbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a34812f582bdf0a89b0d7e9a0b86dddbf">isRevert</a> = false</td></tr>
<tr class="separator:a34812f582bdf0a89b0d7e9a0b86dddbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Attributs privés</h2></td></tr>
<tr class="memitem:a1fbc9b3cdfcf2170ef9e1c6aaf86402c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a1fbc9b3cdfcf2170ef9e1c6aaf86402c">sizeCote</a></td></tr>
<tr class="separator:a1fbc9b3cdfcf2170ef9e1c6aaf86402c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b033608b1d9356adabdf48f8afee1ef"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a6b033608b1d9356adabdf48f8afee1ef">px</a></td></tr>
<tr class="separator:a6b033608b1d9356adabdf48f8afee1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af972aa88c0abd18ffa39adba776e1ba7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#af972aa88c0abd18ffa39adba776e1ba7">py</a></td></tr>
<tr class="separator:af972aa88c0abd18ffa39adba776e1ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ee05ba4d971fe0ba5de0cf372cc3dc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a82ee05ba4d971fe0ba5de0cf372cc3dc">center</a></td></tr>
<tr class="separator:a82ee05ba4d971fe0ba5de0cf372cc3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Amis</h2></td></tr>
<tr class="memitem:a29f20507a47833482b3cee839a972f66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a29f20507a47833482b3cee839a972f66">operator==</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;vectShapes, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;vectModel)</td></tr>
<tr class="memdesc:a29f20507a47833482b3cee839a972f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surcharge de l'opérateur de comparaison pour un ensemble figure.  <a href="#a29f20507a47833482b3cee839a972f66">Plus de détails...</a><br /></td></tr>
<tr class="separator:a29f20507a47833482b3cee839a972f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac837cd47c70c0ba96f33db9ae57e4f5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#ac837cd47c70c0ba96f33db9ae57e4f5a">areEqual</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;vectShapes, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;vectModel)</td></tr>
<tr class="memdesc:ac837cd47c70c0ba96f33db9ae57e4f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode de comparaison pour un ensemble figure.  <a href="#ac837cd47c70c0ba96f33db9ae57e4f5a">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac837cd47c70c0ba96f33db9ae57e4f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011759ae83f40587e0f422f2730ecbd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a011759ae83f40587e0f422f2730ecbd4">saveDraw</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;fig)</td></tr>
<tr class="memdesc:a011759ae83f40587e0f422f2730ecbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode de sauvegarder une figure réaliser sur l'interface.  <a href="#a011759ae83f40587e0f422f2730ecbd4">Plus de détails...</a><br /></td></tr>
<tr class="separator:a011759ae83f40587e0f422f2730ecbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa8a7bdf815401f5956bf4a02ecf544"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a6fa8a7bdf815401f5956bf4a02ecf544">drawAllShapes</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;vectShapes, MLV_Color colorShape, MLV_Color colorBorder)</td></tr>
<tr class="memdesc:a6fa8a7bdf815401f5956bf4a02ecf544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode permettant desinner un ensemble de figures de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a> (tous les objets d'un motif de tangram).  <a href="#a6fa8a7bdf815401f5956bf4a02ecf544">Plus de détails...</a><br /></td></tr>
<tr class="separator:a6fa8a7bdf815401f5956bf4a02ecf544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf1440d1bc82b601deaa13c43d70041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a9bf1440d1bc82b601deaa13c43d70041">drawAllShapes</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;vectShapes, std::list&lt; MLV_Color &gt; colorShapes, MLV_Color colorBorder)</td></tr>
<tr class="memdesc:a9bf1440d1bc82b601deaa13c43d70041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surcharge de la méthode drawAllShapes pour un vecteur de couleur.  <a href="#a9bf1440d1bc82b601deaa13c43d70041">Plus de détails...</a><br /></td></tr>
<tr class="separator:a9bf1440d1bc82b601deaa13c43d70041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59332afb2295446dd8b39a3b47bbf9b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a59332afb2295446dd8b39a3b47bbf9b9">isInsideBoard</a> (const int &amp;x, const int &amp;y, const int &amp;width, const int &amp;heigth)</td></tr>
<tr class="memdesc:a59332afb2295446dd8b39a3b47bbf9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Méthode permettant de regardé si un objet va dépasser les bordures de la fenêtre de l'interface.  <a href="#a59332afb2295446dd8b39a3b47bbf9b9">Plus de détails...</a><br /></td></tr>
<tr class="separator:a59332afb2295446dd8b39a3b47bbf9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p>Classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a>. </p>
<p>La classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a> est la class mère des figures du tangram elle permet aprés héritage de construire l'ensemble des figures(rigth_triangle, paralleogram, square) et regroupe l'ensemble des méthodes permettant de manipuler les formes quand celle-ci n'ont pas besoin d'être virtuel. </p>
</div><h2 class="groupheader">Documentation des constructeurs et destructeur</h2>
<a id="aa45bec6f55f33a59991f83a1d0843a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45bec6f55f33a59991f83a1d0843a53">&#9670;&nbsp;</a></span>Shape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geometricShape::Shape::Shape </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sizeCote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructeur de la class <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a>. </p>
<p>Constructeur explicit de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a>.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeCote</td><td>: Taille du coté de la figure. </td></tr>
    <tr><td class="paramname">width</td><td>: Emplacement en ligne du premier point de construction. </td></tr>
    <tr><td class="paramname">height</td><td>: Emplacement en collone du premier point de construction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e4470674c16e4a7058554d473aa5fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4470674c16e4a7058554d473aa5fbf">&#9670;&nbsp;</a></span>~Shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual geometricShape::Shape::~Shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructeur de la class <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a>. </p>
<p>Destructeur de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a> déclaré en virtuel car on cette class est hérité par rigth_triangle, paralleogram et square. Le destructeur n'a pas d'implémentation car les attribut sont statics. </p>

</div>
</div>
<a id="ad141f6bc47907a6f19825430fc3638e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad141f6bc47907a6f19825430fc3638e2">&#9670;&nbsp;</a></span>Shape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">geometricShape::Shape::Shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>cshape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur de copie. </p>
<p>Constructeur de copie de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a>. </p><dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">cshape</td><td>: Figure à copier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions membres</h2>
<a id="af666bd629db0595afa79982548b6cf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af666bd629db0595afa79982548b6cf78">&#9670;&nbsp;</a></span>display()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geometricShape::Shape::display </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode permettant d'afficher sur la console l'objet souhaité. </p>
<p>Méthode virtuel car dépend de la figure appelée. </p><dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>: Flux de sortie sur la console (par défault std::cout). </td></tr>
  </table>
  </dd>
</dl>

<p>Réimplémentée dans <a class="el" href="classgeometric_shape_1_1_parallelogram.html#a3e9f220add215e8f594da75daf19a8c1">geometricShape::Parallelogram</a>, <a class="el" href="classgeometric_shape_1_1_square.html#a945551a983f2476d6e39c572f7f66ec9">geometricShape::Square</a>, et <a class="el" href="classgeometric_shape_1_1_rigth_triangle.html#ad5d1fe984fa6fa7c6e6764b1530eeeaa">geometricShape::RigthTriangle</a>.</p>

</div>
</div>
<a id="ae16cafaabf0742f54f718ba319c1afee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16cafaabf0742f54f718ba319c1afee">&#9670;&nbsp;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::draw </td>
          <td>(</td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>colorShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>colorBorder</em> = <code>MLV_COLOR_BLACK</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode permettant desinner une figure de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a>. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">colorShape</td><td>: Couleur de l'intérieur de la figure. </td></tr>
    <tr><td class="paramname">colorBorder</td><td>: Couleur de la bordure de la figure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa22dac66031a0b7e87615d8402891d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22dac66031a0b7e87615d8402891d90">&#9670;&nbsp;</a></span>getCenter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; geometricShape::Shape::getCenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Geter pour center la class <a class="el" href="namespacegeometric_shape.html" title="Espace de nommage geometricShape regroupant les différentes classes de figures utilisées. ">geometricShape</a>. </p>
<p>Renvoie les coordonnées du centre de la figure. </p>

</div>
</div>
<a id="a9e9ef6bc53c00e40d8be8d46709d57ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9ef6bc53c00e40d8be8d46709d57ad">&#9670;&nbsp;</a></span>getPx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; geometricShape::Shape::getPx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Geter pour px la class <a class="el" href="namespacegeometric_shape.html" title="Espace de nommage geometricShape regroupant les différentes classes de figures utilisées. ">geometricShape</a>. </p>
<p>Renvoie les coordonnées en x de la figure </p>

</div>
</div>
<a id="a2191b95552288e73c4b7b4852b063d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2191b95552288e73c4b7b4852b063d12">&#9670;&nbsp;</a></span>getPy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; geometricShape::Shape::getPy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Geter pour py de la class <a class="el" href="namespacegeometric_shape.html" title="Espace de nommage geometricShape regroupant les différentes classes de figures utilisées. ">geometricShape</a>. </p>
<p>Renvoie les coordonnées en y de la figure. </p>

</div>
</div>
<a id="af20eddd3fa1bf6ec35f9ed942c21d488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20eddd3fa1bf6ec35f9ed942c21d488">&#9670;&nbsp;</a></span>getSizeCote()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double geometricShape::Shape::getSizeCote </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Geter pour sizeCote de la class <a class="el" href="namespacegeometric_shape.html" title="Espace de nommage geometricShape regroupant les différentes classes de figures utilisées. ">geometricShape</a>. </p>
<p>Renvoie la taille du coté de construction de la forme. </p>

</div>
</div>
<a id="a10713940996e923488745dfa7dbe1c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10713940996e923488745dfa7dbe1c46">&#9670;&nbsp;</a></span>isInside()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geometricShape::Shape::isInside </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode permettant de regardé sur un clique de la souris est compris dans un objet. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>: Postion x de la souris. </td></tr>
    <tr><td class="paramname">y</td><td>: Postion y de la souris. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2882c1c1968a92bdccd568f08a9c1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2882c1c1968a92bdccd568f08a9c1d1">&#9670;&nbsp;</a></span>magnetisme()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool geometricShape::Shape::magnetisme </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test si deux objets peuvent être magnétisé. </p>
<p>Test si l'objet en praramètre et l'objet courant sont égal. Si le test est vrai alors l'objet <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a> en paramètre prend la valeur de l'objet courant. Renvoie un booléen pour savoir si le magnétisme à eu lieu. </p><dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">s2</td><td>: Objet à tester et à modifier si les test est vrai. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56c25b597e4a88d0a5d099efd3dfab9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c25b597e4a88d0a5d099efd3dfab9d">&#9670;&nbsp;</a></span>moveShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::moveShape </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>xInside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>yInside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>motif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>motifShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>motifBorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; MLV_Color &gt; &amp;&#160;</td>
          <td class="paramname"><em>colorfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; MLV_Color &gt;::iterator&#160;</td>
          <td class="paramname"><em>fig_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_board.html">Board</a> &amp;&#160;</td>
          <td class="paramname"><em>board</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>wincondi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode permettant de géré les events utilisateur et les rotation/translation des figures. </p>
<p>La méthode moveShape.</p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">xInside</td><td>: Position en x de la souris. </td></tr>
    <tr><td class="paramname">yInside</td><td>: Position en y de la souris. </td></tr>
    <tr><td class="paramname">fig</td><td>: Ensembles des figures de l'utilisateur à bouger/redesinner. </td></tr>
    <tr><td class="paramname">motif</td><td>: Ensembles des figures de du modèle à redesinner. </td></tr>
    <tr><td class="paramname">motifShape</td><td>: Couleur de l'intérieur du motif. </td></tr>
    <tr><td class="paramname">motifBorder</td><td>: Couleur du contour du motif. </td></tr>
    <tr><td class="paramname">colorfig</td><td>: Vecteur couleur de la figure. </td></tr>
    <tr><td class="paramname">fig_num</td><td>: Itérateur permetant de connaitre la couleur de la figure sélectionner. </td></tr>
    <tr><td class="paramname">board</td><td>: Objet de la class <a class="el" href="class_board.html" title="Classe représentant le plateau de jeu. ">Board</a> permetant de redessiner le fond de la fenêtre en gris. </td></tr>
    <tr><td class="paramname">wincondi</td><td>: Booléen pour connaitre l'état du jeu. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b52ac575add3225201f29d5b81647f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b52ac575add3225201f29d5b81647f8">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Foncteur de la méthode translate qui réalise donc la translation d'un objet. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>: Position en x de la souris. </td></tr>
    <tr><td class="paramname">y</td><td>: Position en y de la souris. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef5e79f1181e8284aca3323c56135cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5e79f1181e8284aca3323c56135cd6">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a>&amp; geometricShape::Shape::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>cshape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opérateur de copie. </p>
<p>Assigment par copie de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a>. </p><dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">cshape</td><td>: Figure à copier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20194d8e1bd7a66d64e7874341498a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20194d8e1bd7a66d64e7874341498a72">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geometricShape::Shape::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>cshape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Surcharge de l'opérateur de comparaison pour une figure. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">cshape</td><td>: Figure à comparer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Un booléen indiquant l'égalité plus ou moins un seuil par sommets (20% de size_cote). </dd></dl>

</div>
</div>
<a id="a3890a8bbed0312d75df063615ef1a6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3890a8bbed0312d75df063615ef1a6d9">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geometricShape::Shape::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode permettant de faire la symétrie d'un objet. </p>
<p>Déclaré en virtuel car seul le parallelogram necessite une implementation complete de symetrie dans les autres cas on fait une rotation de 180°. </p>

<p>Réimplémentée dans <a class="el" href="classgeometric_shape_1_1_parallelogram.html#a7e21f9f5a2461973cf3cc3c14efb6e1a">geometricShape::Parallelogram</a>.</p>

</div>
</div>
<a id="a2c958faaa126d4190304be1acf3328b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c958faaa126d4190304be1acf3328b9">&#9670;&nbsp;</a></span>rotateCenter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::rotateCenter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y0</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode permettant de faire la rotation d'un objet par rapport à son centre. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>: Angle de la rotation. </td></tr>
    <tr><td class="paramname">x</td><td>: Position en x de la souris. </td></tr>
    <tr><td class="paramname">y</td><td>: Position en y de la souris. </td></tr>
    <tr><td class="paramname">x0</td><td>: Position de la souris en x à n-1 ( pour obtenir deux vecteurs). </td></tr>
    <tr><td class="paramname">y0</td><td>: Position de la souris en y à n-1 ( pour obtenir deux vecteurs). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54b2ed849b4838b665bc46fcd924bdf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b2ed849b4838b665bc46fcd924bdf2">&#9670;&nbsp;</a></span>rotateHW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::rotateHW </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Méthode permettant de faire la rotation d'un objet par rapport à l'un de ses sommets. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>: Angle de la rotation. </td></tr>
    <tr><td class="paramname">n</td><td>: Numéro du sommet dans un objet shape qui sera le centre de la rotation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a393d5df22049c7c5efcab5f96a2d9018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393d5df22049c7c5efcab5f96a2d9018">&#9670;&nbsp;</a></span>setShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::setShape </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pXnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pYnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>cnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>scnew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seter de la class <a class="el" href="namespacegeometric_shape.html" title="Espace de nommage geometricShape regroupant les différentes classes de figures utilisées. ">geometricShape</a>. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">pXnew</td><td>: Nouvelle ensemble de coordonnée en x. </td></tr>
    <tr><td class="paramname">pYnew</td><td>: Nouvelle ensemble de coordonnée en x. </td></tr>
    <tr><td class="paramname">cnew</td><td>: Nouveau centre. </td></tr>
    <tr><td class="paramname">scnew</td><td>: Nouvelle taille de coté. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30aff4a795bcfff9f65353cf79d0376f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30aff4a795bcfff9f65353cf79d0376f">&#9670;&nbsp;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::translate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode permettant de faire la translation d'un objet. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>: Position en x de la souris. </td></tr>
    <tr><td class="paramname">y</td><td>: Position en y de la souris. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions amies et associées</h2>
<a id="ac837cd47c70c0ba96f33db9ae57e4f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac837cd47c70c0ba96f33db9ae57e4f5a">&#9670;&nbsp;</a></span>areEqual</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool areEqual </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vectShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vectModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode de comparaison pour un ensemble figure. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Un booléen indiquant l'égalité plus ou moins un seuil (20% de size_cote) </dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectShapes</td><td>: Figures de l'utilisateur à comparer aux modèles. </td></tr>
    <tr><td class="paramname">vectModel</td><td>: Figures modèles à comparer à la figure utilisateur. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fa8a7bdf815401f5956bf4a02ecf544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa8a7bdf815401f5956bf4a02ecf544">&#9670;&nbsp;</a></span>drawAllShapes <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawAllShapes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vectShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>colorShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>colorBorder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode permettant desinner un ensemble de figures de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Classe Shape. ">Shape</a> (tous les objets d'un motif de tangram). </p>
<p>Fait appel à MLV_draw_filled_polygon et MLV_draw_polygon. </p><dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectShapes</td><td>: Ensembles des figures de l'utilisateur à desinner. </td></tr>
    <tr><td class="paramname">colorShape</td><td>: Couleur de la forme. </td></tr>
    <tr><td class="paramname">colorBorder</td><td>: Couleur du contour. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bf1440d1bc82b601deaa13c43d70041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf1440d1bc82b601deaa13c43d70041">&#9670;&nbsp;</a></span>drawAllShapes <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawAllShapes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vectShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; MLV_Color &gt;&#160;</td>
          <td class="paramname"><em>colorShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>colorBorder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Surcharge de la méthode drawAllShapes pour un vecteur de couleur. </p>
<p>Fait appel à MLV_draw_filled_polygon et MLV_draw_polygon. </p><dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectShapes</td><td>: Ensembles des figures de l'utilisateur à desinner. </td></tr>
    <tr><td class="paramname">colorShapes</td><td>: Vecteur de couleurs de la forme. </td></tr>
    <tr><td class="paramname">colorBorder</td><td>: Couleur du contour. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59332afb2295446dd8b39a3b47bbf9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59332afb2295446dd8b39a3b47bbf9b9">&#9670;&nbsp;</a></span>isInsideBoard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isInsideBoard </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>heigth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode permettant de regardé si un objet va dépasser les bordures de la fenêtre de l'interface. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>: Postion x de la souris. </td></tr>
    <tr><td class="paramname">y</td><td>: Postion y de la souris. </td></tr>
    <tr><td class="paramname">width</td><td>: Position du board en x dans la fenêtre. </td></tr>
    <tr><td class="paramname">heigth</td><td>: Position du board en y dans la fenêtre. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29f20507a47833482b3cee839a972f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f20507a47833482b3cee839a972f66">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vectShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vectModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Surcharge de l'opérateur de comparaison pour un ensemble figure. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Obsolète:</a></b></dt><dd>Pas Opérative pour l'instant utiliser areEqual.</dd></dl>
<p>Fait appel à la surcharge de l' operator== pour une figure afin de comparé un ensemble de figure. </p><dl class="section return"><dt>Renvoie</dt><dd>Un booléen indiquant l'égalité plus ou moins un seuil par sommets (20% de size_cote) </dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectShapes</td><td>: Figures de l'utilisateur à comparer aux modèles. </td></tr>
    <tr><td class="paramname">vectModel</td><td>: Figures modèles à comparer à la figure utilisateur. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a011759ae83f40587e0f422f2730ecbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011759ae83f40587e0f422f2730ecbd4">&#9670;&nbsp;</a></span>saveDraw</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saveDraw </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Méthode de sauvegarder une figure réaliser sur l'interface. </p>
<p>Sauvegarde les positions x et y de pixels d'une figure ainsi que leurs centres et leur taille dans le fichier savefig.txt. </p><dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">fig</td><td>: Ensembles des figures de l'utilisateur à sauvegarder. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Documentation des données membres</h2>
<a id="a82ee05ba4d971fe0ba5de0cf372cc3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82ee05ba4d971fe0ba5de0cf372cc3dc">&#9670;&nbsp;</a></span>center</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; geometricShape::Shape::center</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coordonnées du centre. </p>

</div>
</div>
<a id="a34812f582bdf0a89b0d7e9a0b86dddbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34812f582bdf0a89b0d7e9a0b86dddbf">&#9670;&nbsp;</a></span>isRevert</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool geometricShape::Shape::isRevert = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Booléen pour savoir si une symétrie à été effectuée. </p>

</div>
</div>
<a id="a6b033608b1d9356adabdf48f8afee1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b033608b1d9356adabdf48f8afee1ef">&#9670;&nbsp;</a></span>px</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; geometricShape::Shape::px</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coordonnées en x. </p>

</div>
</div>
<a id="af972aa88c0abd18ffa39adba776e1ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af972aa88c0abd18ffa39adba776e1ba7">&#9670;&nbsp;</a></span>py</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; geometricShape::Shape::py</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Coordonnées en y. </p>

</div>
</div>
<a id="a1fbc9b3cdfcf2170ef9e1c6aaf86402c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbc9b3cdfcf2170ef9e1c6aaf86402c">&#9670;&nbsp;</a></span>sizeCote</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double geometricShape::Shape::sizeCote</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Taille du coté de la forme. </p>

</div>
</div>
<hr/>La documentation de cette classe a été générée à partir du fichier suivant :<ul>
<li>include/<a class="el" href="shape_8hpp_source.html">shape.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
