<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tangram: Référence de la classe geometricShape::Shape</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="titre.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tangram
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Recherche');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegeometric_shape.html">geometricShape</a></li><li class="navelem"><a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Fonctions membres publiques</a> &#124;
<a href="#pro-methods">Fonctions membres protégées</a> &#124;
<a href="#pro-attribs">Attributs protégés</a> &#124;
<a href="#friends">Amis</a> &#124;
<a href="classgeometric_shape_1_1_shape-members.html">Liste de tous les membres</a>  </div>
  <div class="headertitle">
<div class="title">Référence de la classe geometricShape::Shape</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a>. La class <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a> est la class mère des figures du tangram elle permet aprés héritage de construire l'ensemble des figures(rigth_triangle, paralleogram, square) et regroupe l'ensemble des méthodes permettant de manipuler les formes quand celle-ci n'ont pas besoin d'être virtuel.  
 <a href="classgeometric_shape_1_1_shape.html#details">Plus de détails...</a></p>

<p><code>#include &lt;<a class="el" href="shape_8hpp_source.html">shape.hpp</a>&gt;</code></p>
<div class="dynheader">
Graphe d'héritage de geometricShape::Shape:</div>
<div class="dyncontent">
<div class="center"><img src="classgeometric_shape_1_1_shape__inherit__graph.png" border="0" usemap="#geometric_shape_1_1_shape_inherit__map" alt="Inheritance graph"/></div>
<!-- MAP 0 -->
<center><span class="legend">[<a href="graph_legend.html">légende</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Fonctions membres publiques</h2></td></tr>
<tr class="memitem:aa45bec6f55f33a59991f83a1d0843a53"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#aa45bec6f55f33a59991f83a1d0843a53">Shape</a> (double sizeCote, int width, int height)</td></tr>
<tr class="memdesc:aa45bec6f55f33a59991f83a1d0843a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur.  <a href="#aa45bec6f55f33a59991f83a1d0843a53">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa45bec6f55f33a59991f83a1d0843a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4470674c16e4a7058554d473aa5fbf"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a4e4470674c16e4a7058554d473aa5fbf">~Shape</a> ()</td></tr>
<tr class="memdesc:a4e4470674c16e4a7058554d473aa5fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructeur.  <a href="#a4e4470674c16e4a7058554d473aa5fbf">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4e4470674c16e4a7058554d473aa5fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad141f6bc47907a6f19825430fc3638e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#ad141f6bc47907a6f19825430fc3638e2">Shape</a> (const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;cshape)</td></tr>
<tr class="memdesc:ad141f6bc47907a6f19825430fc3638e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructeur de copie.  <a href="#ad141f6bc47907a6f19825430fc3638e2">Plus de détails...</a><br /></td></tr>
<tr class="separator:ad141f6bc47907a6f19825430fc3638e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5e79f1181e8284aca3323c56135cd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#aef5e79f1181e8284aca3323c56135cd6">operator=</a> (const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;cshape)</td></tr>
<tr class="memdesc:aef5e79f1181e8284aca3323c56135cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operateur de copie.  <a href="#aef5e79f1181e8284aca3323c56135cd6">Plus de détails...</a><br /></td></tr>
<tr class="separator:aef5e79f1181e8284aca3323c56135cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20194d8e1bd7a66d64e7874341498a72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a20194d8e1bd7a66d64e7874341498a72">operator==</a> (const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;cshape) const</td></tr>
<tr class="memdesc:a20194d8e1bd7a66d64e7874341498a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surcharge de l'opérateur de comparaison pour une figure.  <a href="#a20194d8e1bd7a66d64e7874341498a72">Plus de détails...</a><br /></td></tr>
<tr class="separator:a20194d8e1bd7a66d64e7874341498a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c25b597e4a88d0a5d099efd3dfab9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a56c25b597e4a88d0a5d099efd3dfab9d">moveShape</a> (int &amp;xInside, int &amp;yInside, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;fig, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;motif, MLV_Color motifShape, MLV_Color motifBorder, std::list&lt; MLV_Color &gt; &amp;colorfig, std::list&lt; MLV_Color &gt;::iterator fig_num, <a class="el" href="class_board.html">Board</a> &amp;board, bool &amp;wincondi)</td></tr>
<tr class="memdesc:a56c25b597e4a88d0a5d099efd3dfab9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode permettant de géré les events utilisateur et les rotation/translation des figures.  <a href="#a56c25b597e4a88d0a5d099efd3dfab9d">Plus de détails...</a><br /></td></tr>
<tr class="separator:a56c25b597e4a88d0a5d099efd3dfab9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16cafaabf0742f54f718ba319c1afee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#ae16cafaabf0742f54f718ba319c1afee">draw</a> (MLV_Color colorShape, MLV_Color colorBorder=MLV_COLOR_BLACK) const</td></tr>
<tr class="memdesc:ae16cafaabf0742f54f718ba319c1afee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode permettant desinner une figure de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a>. ....  <a href="#ae16cafaabf0742f54f718ba319c1afee">Plus de détails...</a><br /></td></tr>
<tr class="separator:ae16cafaabf0742f54f718ba319c1afee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af666bd629db0595afa79982548b6cf78"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#af666bd629db0595afa79982548b6cf78">display</a> (std::ostream &amp;out=std::cout) const</td></tr>
<tr class="memdesc:af666bd629db0595afa79982548b6cf78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode permettant d'afficher sur la console l'objet souhaité. Méthode virtuel car dépend de la figure appelée.  <a href="#af666bd629db0595afa79982548b6cf78">Plus de détails...</a><br /></td></tr>
<tr class="separator:af666bd629db0595afa79982548b6cf78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10713940996e923488745dfa7dbe1c46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a10713940996e923488745dfa7dbe1c46">isInside</a> (const int &amp;x, const int &amp;y) const</td></tr>
<tr class="memdesc:a10713940996e923488745dfa7dbe1c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode permettant de regardé sur un clique de la souris est compris dans un objet.  <a href="#a10713940996e923488745dfa7dbe1c46">Plus de détails...</a><br /></td></tr>
<tr class="separator:a10713940996e923488745dfa7dbe1c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3890a8bbed0312d75df063615ef1a6d9"><td class="memItemLeft" align="right" valign="top"><a id="a3890a8bbed0312d75df063615ef1a6d9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a3890a8bbed0312d75df063615ef1a6d9">reverse</a> ()</td></tr>
<tr class="memdesc:a3890a8bbed0312d75df063615ef1a6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode permettant de faire la symétrie d'un objet. déclaré en virtuel car seul le parallelogram necessite une implementation complete de symetrie dans les autres cas on fait une rotation de 180°. <br /></td></tr>
<tr class="separator:a3890a8bbed0312d75df063615ef1a6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b2ed849b4838b665bc46fcd924bdf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a54b2ed849b4838b665bc46fcd924bdf2">rotateHW</a> (int angle, unsigned int n)</td></tr>
<tr class="memdesc:a54b2ed849b4838b665bc46fcd924bdf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode permettant de faire la rotation d'un objet par rapport à l'un de ses sommets. utiliser danss le main pour constuire une figure de base.  <a href="#a54b2ed849b4838b665bc46fcd924bdf2">Plus de détails...</a><br /></td></tr>
<tr class="separator:a54b2ed849b4838b665bc46fcd924bdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393d5df22049c7c5efcab5f96a2d9018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a393d5df22049c7c5efcab5f96a2d9018">setShape</a> (std::vector&lt; double &gt; &amp;pXnew, std::vector&lt; double &gt; &amp;pYnew, std::vector&lt; double &gt; &amp;cnew, double &amp;scnew)</td></tr>
<tr class="memdesc:a393d5df22049c7c5efcab5f96a2d9018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seter de la class <a class="el" href="namespacegeometric_shape.html" title="geometricShape. Le namespace geometricShape permet de regouper les différentes figures et fonction ex...">geometricShape</a>.  <a href="#a393d5df22049c7c5efcab5f96a2d9018">Plus de détails...</a><br /></td></tr>
<tr class="separator:a393d5df22049c7c5efcab5f96a2d9018"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Fonctions membres protégées</h2></td></tr>
<tr class="memitem:af20eddd3fa1bf6ec35f9ed942c21d488"><td class="memItemLeft" align="right" valign="top"><a id="af20eddd3fa1bf6ec35f9ed942c21d488"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#af20eddd3fa1bf6ec35f9ed942c21d488">getSizeCote</a> () const</td></tr>
<tr class="memdesc:af20eddd3fa1bf6ec35f9ed942c21d488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geter pour sizeCote de la class <a class="el" href="namespacegeometric_shape.html" title="geometricShape. Le namespace geometricShape permet de regouper les différentes figures et fonction ex...">geometricShape</a> renvoie la taille du coté de construction de la forme. <br /></td></tr>
<tr class="separator:af20eddd3fa1bf6ec35f9ed942c21d488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9ef6bc53c00e40d8be8d46709d57ad"><td class="memItemLeft" align="right" valign="top"><a id="a9e9ef6bc53c00e40d8be8d46709d57ad"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a9e9ef6bc53c00e40d8be8d46709d57ad">getPx</a> () const</td></tr>
<tr class="memdesc:a9e9ef6bc53c00e40d8be8d46709d57ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geter pour px la class <a class="el" href="namespacegeometric_shape.html" title="geometricShape. Le namespace geometricShape permet de regouper les différentes figures et fonction ex...">geometricShape</a> renvoie les coordonnées en x de la figure. <br /></td></tr>
<tr class="separator:a9e9ef6bc53c00e40d8be8d46709d57ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2191b95552288e73c4b7b4852b063d12"><td class="memItemLeft" align="right" valign="top"><a id="a2191b95552288e73c4b7b4852b063d12"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a2191b95552288e73c4b7b4852b063d12">getPy</a> () const</td></tr>
<tr class="memdesc:a2191b95552288e73c4b7b4852b063d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geter pour py la class <a class="el" href="namespacegeometric_shape.html" title="geometricShape. Le namespace geometricShape permet de regouper les différentes figures et fonction ex...">geometricShape</a> renvoie les coordonnées en y de la figure. <br /></td></tr>
<tr class="separator:a2191b95552288e73c4b7b4852b063d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22dac66031a0b7e87615d8402891d90"><td class="memItemLeft" align="right" valign="top"><a id="aa22dac66031a0b7e87615d8402891d90"></a>
std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#aa22dac66031a0b7e87615d8402891d90">getCenter</a> () const</td></tr>
<tr class="memdesc:aa22dac66031a0b7e87615d8402891d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geter pour center la class <a class="el" href="namespacegeometric_shape.html" title="geometricShape. Le namespace geometricShape permet de regouper les différentes figures et fonction ex...">geometricShape</a> renvoie les coordonnées du centre de la figure. <br /></td></tr>
<tr class="separator:aa22dac66031a0b7e87615d8402891d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c958faaa126d4190304be1acf3328b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a2c958faaa126d4190304be1acf3328b9">rotateCenter</a> (int angle, int x=0, int y=0, int x0=0, int y0=0)</td></tr>
<tr class="memdesc:a2c958faaa126d4190304be1acf3328b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode permettant de faire la rotation d'un objet par rapport à son centre.  <a href="#a2c958faaa126d4190304be1acf3328b9">Plus de détails...</a><br /></td></tr>
<tr class="separator:a2c958faaa126d4190304be1acf3328b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30aff4a795bcfff9f65353cf79d0376f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a30aff4a795bcfff9f65353cf79d0376f">translate</a> (int x, int y)</td></tr>
<tr class="memdesc:a30aff4a795bcfff9f65353cf79d0376f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode permettant de faire la translation d'un objet.  <a href="#a30aff4a795bcfff9f65353cf79d0376f">Plus de détails...</a><br /></td></tr>
<tr class="separator:a30aff4a795bcfff9f65353cf79d0376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b52ac575add3225201f29d5b81647f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a4b52ac575add3225201f29d5b81647f8">operator()</a> (int x, int y)</td></tr>
<tr class="memdesc:a4b52ac575add3225201f29d5b81647f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Foncteur de la méthode translate qui réalise donc la translation d'un objet.  <a href="#a4b52ac575add3225201f29d5b81647f8">Plus de détails...</a><br /></td></tr>
<tr class="separator:a4b52ac575add3225201f29d5b81647f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2882c1c1968a92bdccd568f08a9c1d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#af2882c1c1968a92bdccd568f08a9c1d1">magnetisme</a> (const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;s2)</td></tr>
<tr class="memdesc:af2882c1c1968a92bdccd568f08a9c1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test si deux objets peuvent être magnétisé Test si l'objet en praramètre et l'objet courant sont égal. Si le test est vrai alors l'objet <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a> en paramètre prend la valeur de l'objet courant. Renvoie un booléen pour savoir si le magnétisme à eu lieu.  <a href="#af2882c1c1968a92bdccd568f08a9c1d1">Plus de détails...</a><br /></td></tr>
<tr class="separator:af2882c1c1968a92bdccd568f08a9c1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Attributs protégés</h2></td></tr>
<tr class="memitem:a34812f582bdf0a89b0d7e9a0b86dddbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a34812f582bdf0a89b0d7e9a0b86dddbf">isRevert</a> = false</td></tr>
<tr class="separator:a34812f582bdf0a89b0d7e9a0b86dddbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Amis</h2></td></tr>
<tr class="memitem:a29f20507a47833482b3cee839a972f66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a29f20507a47833482b3cee839a972f66">operator==</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;vectShapes, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;vectModel)</td></tr>
<tr class="memdesc:a29f20507a47833482b3cee839a972f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surcharge de l'opérateur de comparaison pour un ensemble figure.  <a href="#a29f20507a47833482b3cee839a972f66">Plus de détails...</a><br /></td></tr>
<tr class="separator:a29f20507a47833482b3cee839a972f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac837cd47c70c0ba96f33db9ae57e4f5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#ac837cd47c70c0ba96f33db9ae57e4f5a">areEqual</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;vectShapes, const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;vectModel)</td></tr>
<tr class="memdesc:ac837cd47c70c0ba96f33db9ae57e4f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de comparaison pour un ensemble figure.  <a href="#ac837cd47c70c0ba96f33db9ae57e4f5a">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac837cd47c70c0ba96f33db9ae57e4f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011759ae83f40587e0f422f2730ecbd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a011759ae83f40587e0f422f2730ecbd4">saveDraw</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;fig)</td></tr>
<tr class="memdesc:a011759ae83f40587e0f422f2730ecbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode de sauvegarder une figure réaliser sur l'interface. Sauvegarde les positions x et y de pixels d'une figure ainsi que leurs centres et leur taille dans le fichier savefig.txt.  <a href="#a011759ae83f40587e0f422f2730ecbd4">Plus de détails...</a><br /></td></tr>
<tr class="separator:a011759ae83f40587e0f422f2730ecbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa8a7bdf815401f5956bf4a02ecf544"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a6fa8a7bdf815401f5956bf4a02ecf544">drawAllShapes</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;vectShapes, MLV_Color colorShape, MLV_Color colorBorder)</td></tr>
<tr class="memdesc:a6fa8a7bdf815401f5956bf4a02ecf544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode permettant desinner un ensemble de figures de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a> (tous les objets d'un motif de tangram). Fait appel à MLV_draw_filled_polygon et MLV_draw_polygon.  <a href="#a6fa8a7bdf815401f5956bf4a02ecf544">Plus de détails...</a><br /></td></tr>
<tr class="separator:a6fa8a7bdf815401f5956bf4a02ecf544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf1440d1bc82b601deaa13c43d70041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a9bf1440d1bc82b601deaa13c43d70041">drawAllShapes</a> (const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;vectShapes, std::list&lt; MLV_Color &gt; colorShapes, MLV_Color colorBorder)</td></tr>
<tr class="memdesc:a9bf1440d1bc82b601deaa13c43d70041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode permettant de desinner un ensemble de figures de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a> (tous les objets d'un motif de tangram). Fait appel à MLV_draw_filled_polygon et MLV_draw_polygon.  <a href="#a9bf1440d1bc82b601deaa13c43d70041">Plus de détails...</a><br /></td></tr>
<tr class="separator:a9bf1440d1bc82b601deaa13c43d70041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59332afb2295446dd8b39a3b47bbf9b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeometric_shape_1_1_shape.html#a59332afb2295446dd8b39a3b47bbf9b9">isInsideBoard</a> (const int &amp;x, const int &amp;y, const int &amp;width, const int &amp;heigth)</td></tr>
<tr class="memdesc:a59332afb2295446dd8b39a3b47bbf9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methode permettant de regardé si un objet va dépasser les bordures de la fenêtre de l'interface.  <a href="#a59332afb2295446dd8b39a3b47bbf9b9">Plus de détails...</a><br /></td></tr>
<tr class="separator:a59332afb2295446dd8b39a3b47bbf9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Description détaillée</h2>
<div class="textblock"><p><a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a>. La class <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a> est la class mère des figures du tangram elle permet aprés héritage de construire l'ensemble des figures(rigth_triangle, paralleogram, square) et regroupe l'ensemble des méthodes permettant de manipuler les formes quand celle-ci n'ont pas besoin d'être virtuel. </p>
</div><h2 class="groupheader">Documentation des constructeurs et destructeur</h2>
<a id="aa45bec6f55f33a59991f83a1d0843a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45bec6f55f33a59991f83a1d0843a53">&#9670;&nbsp;</a></span>Shape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geometricShape::Shape::Shape </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sizeCote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructeur. </p>
<p>Constructeur explicit de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a></p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">sizeCote</td><td>: taille du coté de la figure </td></tr>
    <tr><td class="paramname">width</td><td>: emplacement en ligne du premier point de construction </td></tr>
    <tr><td class="paramname">height</td><td>: emplacement en collone du premier point de construction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e4470674c16e4a7058554d473aa5fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4470674c16e4a7058554d473aa5fbf">&#9670;&nbsp;</a></span>~Shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual geometricShape::Shape::~Shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructeur. </p>
<p>Destructeur de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a> déclaré en virtuel car on cette class est hérité par rigth_triangle, paralleogram et square. Le destructeur n'a pas d'implémentation car les attribut sont statics. </p>

</div>
</div>
<a id="ad141f6bc47907a6f19825430fc3638e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad141f6bc47907a6f19825430fc3638e2">&#9670;&nbsp;</a></span>Shape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">geometricShape::Shape::Shape </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>cshape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructeur de copie. </p>
<p>Constructeur de copie de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a> </p><dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">cshape</td><td>: figure à copier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions membres</h2>
<a id="af666bd629db0595afa79982548b6cf78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af666bd629db0595afa79982548b6cf78">&#9670;&nbsp;</a></span>display()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geometricShape::Shape::display </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methode permettant d'afficher sur la console l'objet souhaité. Méthode virtuel car dépend de la figure appelée. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>: flux de sortie sur la console. </td></tr>
  </table>
  </dd>
</dl>

<p>Réimplémentée dans <a class="el" href="classgeometric_shape_1_1_rigth_triangle.html#ad5d1fe984fa6fa7c6e6764b1530eeeaa">geometricShape::RigthTriangle</a>, <a class="el" href="classgeometric_shape_1_1_parallelogram.html#a3e9f220add215e8f594da75daf19a8c1">geometricShape::Parallelogram</a>, et <a class="el" href="classgeometric_shape_1_1_square.html#a945551a983f2476d6e39c572f7f66ec9">geometricShape::Square</a>.</p>

</div>
</div>
<a id="ae16cafaabf0742f54f718ba319c1afee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16cafaabf0742f54f718ba319c1afee">&#9670;&nbsp;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::draw </td>
          <td>(</td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>colorShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>colorBorder</em> = <code>MLV_COLOR_BLACK</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Methode permettant desinner une figure de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a>. .... </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">colorShape</td><td>: </td></tr>
    <tr><td class="paramname">colorBorder</td><td>: </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10713940996e923488745dfa7dbe1c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10713940996e923488745dfa7dbe1c46">&#9670;&nbsp;</a></span>isInside()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geometricShape::Shape::isInside </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Methode permettant de regardé sur un clique de la souris est compris dans un objet. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>: postion x de la souris. </td></tr>
    <tr><td class="paramname">y</td><td>: postion y de la souris. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2882c1c1968a92bdccd568f08a9c1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2882c1c1968a92bdccd568f08a9c1d1">&#9670;&nbsp;</a></span>magnetisme()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool geometricShape::Shape::magnetisme </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>s2</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test si deux objets peuvent être magnétisé Test si l'objet en praramètre et l'objet courant sont égal. Si le test est vrai alors l'objet <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a> en paramètre prend la valeur de l'objet courant. Renvoie un booléen pour savoir si le magnétisme à eu lieu. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">s2</td><td>: Objet à tester et à modifier si les test est vrai. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56c25b597e4a88d0a5d099efd3dfab9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c25b597e4a88d0a5d099efd3dfab9d">&#9670;&nbsp;</a></span>moveShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::moveShape </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>xInside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>yInside</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>motif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>motifShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>motifBorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; MLV_Color &gt; &amp;&#160;</td>
          <td class="paramname"><em>colorfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; MLV_Color &gt;::iterator&#160;</td>
          <td class="paramname"><em>fig_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_board.html">Board</a> &amp;&#160;</td>
          <td class="paramname"><em>board</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>wincondi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Methode permettant de géré les events utilisateur et les rotation/translation des figures. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">xInside</td><td>: position en x de la souris. </td></tr>
    <tr><td class="paramname">yInside</td><td>: position en y de la souris. </td></tr>
    <tr><td class="paramname">fig</td><td>: ensembles des figures de l'utilisateur à bouger/redesinner. </td></tr>
    <tr><td class="paramname">motif</td><td>: ensembles des figures de du modèle à redesinner. </td></tr>
    <tr><td class="paramname">colorfig</td><td>: vecteur couleur de la figure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b52ac575add3225201f29d5b81647f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b52ac575add3225201f29d5b81647f8">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Foncteur de la méthode translate qui réalise donc la translation d'un objet. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>: position en x de la souris. </td></tr>
    <tr><td class="paramname">y</td><td>: position en y de la souris. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef5e79f1181e8284aca3323c56135cd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5e79f1181e8284aca3323c56135cd6">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a>&amp; geometricShape::Shape::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>cshape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operateur de copie. </p>
<p>Assigment par copie de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a> </p><dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">cshape</td><td>: figure à copier. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20194d8e1bd7a66d64e7874341498a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20194d8e1bd7a66d64e7874341498a72">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool geometricShape::Shape::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgeometric_shape_1_1_shape.html">Shape</a> &amp;&#160;</td>
          <td class="paramname"><em>cshape</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Surcharge de l'opérateur de comparaison pour une figure. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">cshape</td><td>: figure à comparer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Renvoie</dt><dd>Un booléen indiquant l'égalité plus ou moins un seuil par sommets (20% de size_cote) </dd></dl>

</div>
</div>
<a id="a2c958faaa126d4190304be1acf3328b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c958faaa126d4190304be1acf3328b9">&#9670;&nbsp;</a></span>rotateCenter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::rotateCenter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y0</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methode permettant de faire la rotation d'un objet par rapport à son centre. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>: angle de la rotation. </td></tr>
    <tr><td class="paramname">x</td><td>: position en x de la souris. </td></tr>
    <tr><td class="paramname">y</td><td>: position en y de la souris. </td></tr>
    <tr><td class="paramname">x0</td><td>: position de la souris en x à n-1 ( pour obtenir un deux vecteurs). </td></tr>
    <tr><td class="paramname">y0</td><td>: position de la souris en yà n-1 ( pour obtenir un deux vecteurs). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54b2ed849b4838b665bc46fcd924bdf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b2ed849b4838b665bc46fcd924bdf2">&#9670;&nbsp;</a></span>rotateHW()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::rotateHW </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Methode permettant de faire la rotation d'un objet par rapport à l'un de ses sommets. utiliser danss le main pour constuire une figure de base. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>: angle de la rotation. </td></tr>
    <tr><td class="paramname">n</td><td>: n° du sommet qui sera le centre de la rotation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a393d5df22049c7c5efcab5f96a2d9018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393d5df22049c7c5efcab5f96a2d9018">&#9670;&nbsp;</a></span>setShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::setShape </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pXnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>pYnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>cnew</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>scnew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seter de la class <a class="el" href="namespacegeometric_shape.html" title="geometricShape. Le namespace geometricShape permet de regouper les différentes figures et fonction ex...">geometricShape</a>. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">pXnew</td><td>: nouvelle ensemble de coordonnée en x. </td></tr>
    <tr><td class="paramname">pYnew</td><td>: nouvelle ensemble de coordonnée en x. </td></tr>
    <tr><td class="paramname">cnew</td><td>: nouveau centre. </td></tr>
    <tr><td class="paramname">scnew</td><td>: nnouvelle taille de coté. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30aff4a795bcfff9f65353cf79d0376f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30aff4a795bcfff9f65353cf79d0376f">&#9670;&nbsp;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void geometricShape::Shape::translate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methode permettant de faire la translation d'un objet. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>: position en x de la souris. </td></tr>
    <tr><td class="paramname">y</td><td>: position en y de la souris. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions amies et associées</h2>
<a id="ac837cd47c70c0ba96f33db9ae57e4f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac837cd47c70c0ba96f33db9ae57e4f5a">&#9670;&nbsp;</a></span>areEqual</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool areEqual </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vectShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vectModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methode de comparaison pour un ensemble figure. </p>
<dl class="section return"><dt>Renvoie</dt><dd>Un booléen indiquant l'égalité plus ou moins un seuil (20% de size_cote) </dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectShapes</td><td>: figures de l'utilisateur à comparer aux modèles. </td></tr>
    <tr><td class="paramname">vectModel</td><td>: figures modèles à comparer à la figure utilisateur. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fa8a7bdf815401f5956bf4a02ecf544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa8a7bdf815401f5956bf4a02ecf544">&#9670;&nbsp;</a></span>drawAllShapes <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawAllShapes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vectShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>colorShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>colorBorder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methode permettant desinner un ensemble de figures de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a> (tous les objets d'un motif de tangram). Fait appel à MLV_draw_filled_polygon et MLV_draw_polygon. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectShapes</td><td>: ensembles des figures de l'utilisateur à desinner. </td></tr>
    <tr><td class="paramname">colorShape</td><td>: couleur de la forme. </td></tr>
    <tr><td class="paramname">colorBorder</td><td>: couleur du contour. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bf1440d1bc82b601deaa13c43d70041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf1440d1bc82b601deaa13c43d70041">&#9670;&nbsp;</a></span>drawAllShapes <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void drawAllShapes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vectShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; MLV_Color &gt;&#160;</td>
          <td class="paramname"><em>colorShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MLV_Color&#160;</td>
          <td class="paramname"><em>colorBorder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methode permettant de desinner un ensemble de figures de la classe <a class="el" href="classgeometric_shape_1_1_shape.html" title="Shape. La class Shape est la class mère des figures du tangram elle permet aprés héritage de construi...">Shape</a> (tous les objets d'un motif de tangram). Fait appel à MLV_draw_filled_polygon et MLV_draw_polygon. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectShapes</td><td>: ensembles des figures de l'utilisateur à desinner. </td></tr>
    <tr><td class="paramname">colorShape</td><td>: vecteur de couleurs de la forme. </td></tr>
    <tr><td class="paramname">colorBorder</td><td>: couleur du contour. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59332afb2295446dd8b39a3b47bbf9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59332afb2295446dd8b39a3b47bbf9b9">&#9670;&nbsp;</a></span>isInsideBoard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isInsideBoard </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>heigth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methode permettant de regardé si un objet va dépasser les bordures de la fenêtre de l'interface. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>: postion x de la souris. </td></tr>
    <tr><td class="paramname">y</td><td>: postion y de la souris. </td></tr>
    <tr><td class="paramname">width</td><td>: </td></tr>
    <tr><td class="paramname">heigth</td><td>: </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29f20507a47833482b3cee839a972f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f20507a47833482b3cee839a972f66">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vectShapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vectModel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Surcharge de l'opérateur de comparaison pour un ensemble figure. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Obsolète:</a></b></dt><dd>Pas Opérative pour l'instant utiliser areEqual. Fait appel à la surcharge de l' operator== pour une figure afin de comparé un ensemble de figure. </dd></dl>
<dl class="section return"><dt>Renvoie</dt><dd>Un booléen indiquant l'égalité plus ou moins un seuil par sommets (20% de size_cote) </dd></dl>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">vectShapes</td><td>: figures de l'utilisateur à comparer aux modèles. </td></tr>
    <tr><td class="paramname">vectModel</td><td>: figures modèles à comparer à la figure utilisateur. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a011759ae83f40587e0f422f2730ecbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a011759ae83f40587e0f422f2730ecbd4">&#9670;&nbsp;</a></span>saveDraw</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saveDraw </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classgeometric_shape_1_1_shape.html">geometricShape::Shape</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methode de sauvegarder une figure réaliser sur l'interface. Sauvegarde les positions x et y de pixels d'une figure ainsi que leurs centres et leur taille dans le fichier savefig.txt. </p>
<dl class="params"><dt>Paramètres</dt><dd>
  <table class="params">
    <tr><td class="paramname">fig</td><td>: ensembles des figures de l'utilisateur à sauvegarder. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Documentation des données membres</h2>
<a id="a34812f582bdf0a89b0d7e9a0b86dddbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34812f582bdf0a89b0d7e9a0b86dddbf">&#9670;&nbsp;</a></span>isRevert</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool geometricShape::Shape::isRevert = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Booléen pour savoir si une symétrie à été effectué </p>

</div>
</div>
<hr/>La documentation de cette classe a été générée à partir du fichier suivant :<ul>
<li>include/<a class="el" href="shape_8hpp_source.html">shape.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
