{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red200\green200\blue200;\red0\green0\blue0;\red152\green152\blue217;\red192\green192\blue192;\red128\green128\blue255;\red170\green170\blue240;\red0\green128\blue128;\red107\green153\blue153;\red128\green0\blue0;\red172\green89\blue89;\red240\green0\blue240;\red240\green200\blue240;\red0\green0\blue160;\red135\green135\blue200;\red0\green160\blue0;\red154\green200\blue154;\red190\green0\blue190;\red190\green137\blue190;\red0\green0\blue255;\red190\green190\blue255;\red224\green160\blue0;\red224\green206\blue159;\red132\green160\blue132;\red255\green0\blue0;\red255\green200\blue200;\red64\green64\blue128;\red133\green133\blue172;\red128\green255\blue255;\red55\green55\blue55;}
{\info{\comment Generated by the Code::Blocks RTF Exporter plugin}
{\title Untitled}}

\deflang1033\pard\plain\f0\fs20 \cb3\cf6\b /*!
\par  *  \b0\cb3\cf8 \\file \cb3\cf6\b shape.hpp
\par  *  \b0\cb3\cf8 \\brief \cb3\cf6\b Le fichier d'entête de shape.cpp.
\par  *  \b0\cb3\cf8 \\author \cb3\cf6\b BEN HAMOUDA Amel & DURAND Aurélien
\par  */
\par 
\par \b0\cb3\cf16 #ifndef SHAPE_H
\par #define SHAPE_H
\par #include <vector>
\par #include <list>
\par #include <iostream>
\par #include <MLV/MLV_all.h>
\par #include <memory> \cb3\cf4 // shared_ptr
\par 
\par \cb3\cf6\b /*! \b0\cb3\cf8 \\class \cb3\cf6\b Board
\par  *  \b0\cb3\cf8 \\brief \cb3\cf6\b Déclaration de l'objet Board.
\par  *
\par  */
\par \b0\cb3\cf14\b class \b0\cb1\cf0 Board\cb3\cf25 ;
\par 
\par \cb3\cf6\b /*!
\par  *  \b0\cb3\cf8 \\namespace \cb3\cf6\b geometricShape
\par  *  \b0\cb3\cf8 \\brief  \cb3\cf6\b Espace de nommage geometricShape regroupant les différentes classes de figures utilisées.
\par  *
\par  *  Le namespace geometricShape permet de regouper les différentes figures et fonctions extern des class utiliser pour le tangram.
\par  *  Les class du namespace sont shape, rigth_triangle, paralleogram, square. 
\par  */
\par \b0\cb3\cf14\b namespace \b0\cb1\cf0 geometricShape \cb3\cf25 \{
\par     \cb3\cf6\b /*!
\par      *  \b0\cb3\cf8 \\class \cb3\cf6\b Shape
\par      *  \b0\cb3\cf8 \\brief \cb3\cf6\b Classe Shape.
\par      *
\par      *  La classe Shape est la class mère des figures du tangram elle permet aprés héritage de construire l'ensemble des figures(rigth_triangle, paralleogram, square)
\par      *  et regroupe l'ensemble des méthodes permettant de manipuler les formes quand celle-ci n'ont pas besoin d'être virtuel.
\par      * 
\par      */
\par     \b0\cb3\cf14\b class \b0\cb1\cf0 Shape \cb3\cf25 \{       
\par         \cb3\cf14\b public\b0\cb3\cf25 :
\par             \cb3\cf14\b static constexpr float \b0\cb1\cf0 PI \cb3\cf25 = \cb3\cf12 3.141592653589793238462643383279\cb3\cf25 ;
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Constructeur de la class Shape.
\par              *
\par              *  Constructeur explicit de la classe Shape.
\par              *
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b sizeCote : Taille du coté de la figure.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b width : Emplacement en ligne du premier point de construction.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b height : Emplacement en collone du premier point de construction.
\par              */
\par             \b0\cb3\cf14\b explicit \b0\cb1\cf0 Shape\cb3\cf25 (\cb3\cf14\b double \b0\cb1\cf0 sizeCote\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 width\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 height\cb3\cf25 );
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Destructeur de la class Shape.
\par              *
\par              *  Destructeur de la classe Shape déclaré en virtuel car on cette class est hérité par rigth_triangle, paralleogram et square.
\par              *  Le destructeur n'a pas d'implémentation car les attribut sont statics.
\par              */
\par             \b0\cb3\cf14\b virtual\b0\cb3\cf25 ~\cb1\cf0 Shape\cb3\cf25 ();
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Constructeur de copie.
\par              *
\par              *  Constructeur de copie de la classe Shape.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b cshape : Figure à copier.
\par              */
\par             \b0\cb1\cf0 Shape\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 Shape \cb3\cf25 &\cb1\cf0 cshape\cb3\cf25 );
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Opérateur de copie.
\par              *
\par              *  Assigment par copie de la classe Shape.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b cshape : Figure à copier.
\par              */
\par             \b0\cb1\cf0 Shape \cb3\cf25 & \cb3\cf14\b operator\b0\cb3\cf25 =(\cb3\cf14\b const \b0\cb1\cf0 Shape \cb3\cf25 &\cb1\cf0 cshape\cb3\cf25 );
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Surcharge de l'opérateur de comparaison pour une figure.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b cshape : Figure à comparer.
\par              *  \b0\cb3\cf8 \\return \cb3\cf6\b Un booléen indiquant l'égalité plus ou moins un seuil par sommets (20% de size_cote).
\par              */
\par             \b0\cb3\cf14\b bool operator\b0\cb3\cf25 ==(\cb3\cf14\b const \b0\cb1\cf0 Shape \cb3\cf25 &\cb1\cf0 cshape\cb3\cf25 ) \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Surcharge de l'opérateur de comparaison pour un ensemble figure
\par              *
\par              *  \b0\cb3\cf8 \\deprecated \cb3\cf6\b Pas Opérative pour l'instant utiliser areEqual.
\par              *
\par              *  Fait appel à la surcharge de l' operator== pour une figure afin de comparé un ensemble de figure.
\par              *  \b0\cb3\cf8 \\return \cb3\cf6\b Un booléen indiquant l'égalité plus ou moins un seuil par sommets (20% de size_cote)
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b vectShapes : Figures de l'utilisateur à comparer aux modèles.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b vectModel : Figures modèles à comparer à la figure utilisateur.
\par              */
\par             \b0\cb3\cf14\b friend bool operator\b0\cb3\cf25 ==(\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectShapes\cb3\cf25 , \cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectModel\cb3\cf25 );
\par       
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Méthode de comparaison pour un ensemble figure.
\par              *
\par              *  \b0\cb3\cf8 \\return \cb3\cf6\b Un booléen indiquant l'égalité plus ou moins un seuil (20% de size_cote)
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b vectShapes : Figures de l'utilisateur à comparer aux modèles.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b vectModel : Figures modèles à comparer à la figure utilisateur.
\par              */
\par             \b0\cb3\cf14\b friend bool \b0\cb1\cf0 areEqual\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectShapes\cb3\cf25 , \cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectModel\cb3\cf25 );
\par            
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Méthode permettant de géré les events utilisateur et les rotation/translation des figures.
\par              *
\par              *  La méthode moveShape.
\par              *
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b xInside : Position en x de la souris.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b yInside :  Position en y de la souris.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b fig : Ensembles des figures de l'utilisateur à bouger/redesinner.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b motif : Ensembles des figures de du modèle à redesinner.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b motifShape : Couleur de l'intérieur du motif.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b motifBorder : Couleur du contour du motif.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b colorfig : Vecteur couleur de la figure.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b fig_num : Itérateur permetant de connaitre la couleur de la figure sélectionner.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b board : Objet de la class Board permetant de redessiner le fond de la fenêtre en gris.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b wincondi : Booléen pour connaitre l'état du jeu.
\par              */        
\par             \b0\cb3\cf14\b void \b0\cb1\cf0 moveShape\cb3\cf25 (\cb3\cf14\b int \b0\cb3\cf25 &\cb1\cf0 xInside\cb3\cf25 , \cb3\cf14\b int \b0\cb3\cf25 &\cb1\cf0 yInside\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 fig\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 MLV_Color motifShape\cb3\cf25 , \cb1\cf0 MLV_Color motifBorder\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > &\cb1\cf0 colorfig\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 >::\cb3\cf16\b iterator  \b0\cb1\cf0 fig_num\cb3\cf25 , \cb1\cf0 Board \cb3\cf25 &\cb1\cf0 board\cb3\cf25 , \cb3\cf14\b bool \b0\cb3\cf25 &\cb1\cf0 wincondi\cb3\cf25 );
\par            
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Méthode permettant desinner une figure de la classe Shape.
\par              * 
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b colorShape : Couleur de l'intérieur de la figure.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b colorBorder : Couleur de la bordure de la figure.
\par              */          
\par             \b0\cb3\cf14\b void \b0\cb1\cf0 draw\cb3\cf25 (\cb1\cf0 MLV_Color colorShape\cb3\cf25 , \cb1\cf0 MLV_Color colorBorder \cb3\cf25 = \cb1\cf0 MLV_COLOR_BLACK\cb3\cf25 ) \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Méthode de sauvegarder une figure réaliser sur l'interface.
\par              *
\par              *  Sauvegarde les positions x et y de pixels d'une figure ainsi que leurs centres et leur taille dans le fichier savefig.txt.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b fig : Ensembles des figures de l'utilisateur à sauvegarder.
\par              */  
\par             \b0\cb3\cf14\b friend void \b0\cb1\cf0 saveDraw\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 fig\cb3\cf25 );
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Méthode permettant desinner un ensemble de figures de la classe Shape (tous les objets d'un motif de tangram).
\par              *
\par              *  Fait appel à MLV_draw_filled_polygon et MLV_draw_polygon.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b vectShapes : Ensembles des figures de l'utilisateur à desinner.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b colorShape : Couleur de la forme.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b colorBorder : Couleur du contour.
\par              */  
\par             \b0\cb3\cf14\b friend void \b0\cb1\cf0 drawAllShapes\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectShapes\cb3\cf25 , \cb1\cf0 MLV_Color colorShape\cb3\cf25 , \cb1\cf0 MLV_Color colorBorder\cb3\cf25 );
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Surcharge de la méthode drawAllShapes pour un vecteur de couleur.
\par              *
\par              *  Fait appel à MLV_draw_filled_polygon et MLV_draw_polygon.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b vectShapes : Ensembles des figures de l'utilisateur à desinner.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b colorShapes : Vecteur de couleurs de la forme.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b colorBorder : Couleur du contour.
\par              */  
\par             \b0\cb3\cf14\b friend void \b0\cb1\cf0 drawAllShapes\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectShapes\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > \cb1\cf0 colorShapes\cb3\cf25 , \cb1\cf0 MLV_Color colorBorder\cb3\cf25 );
\par            
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Méthode permettant d'afficher sur la console l'objet souhaité.
\par              *
\par              *   Méthode virtuel car dépend de la figure appelée.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b out : Flux de sortie sur la console (par défault std::cout).
\par              */  
\par             \b0\cb3\cf14\b virtual void \b0\cb1\cf0 display\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 ostream \cb3\cf25 & \cb1\cf0 out \cb3\cf25 = \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b cout\b0\cb3\cf25 ) \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Méthode permettant de regardé sur un clique de la souris est compris dans un objet.
\par              *
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b x : Postion x de la souris.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b y : Postion y de la souris.
\par              */  
\par             \b0\cb3\cf14\b bool \b0\cb1\cf0 isInside\cb3\cf25 (\cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 x\cb3\cf25 , \cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 y\cb3\cf25 ) \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Méthode permettant de regardé si un objet va dépasser les bordures de la fenêtre de l'interface.
\par              *
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b x : Postion x de la souris.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b y : Postion y de la souris.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b width : Position du board en x dans la fenêtre.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b heigth : Position du board en y dans la fenêtre.
\par              */  
\par             \b0\cb3\cf14\b friend bool \b0\cb1\cf0 isInsideBoard\cb3\cf25 (\cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 x\cb3\cf25 , \cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 y\cb3\cf25 , \cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 width\cb3\cf25 , \cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 heigth\cb3\cf25 );
\par              
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Méthode permettant de faire la symétrie d'un objet.
\par              *
\par              *  Déclaré en virtuel car seul le parallelogram necessite une implementation complete de symetrie dans les autres cas on fait une rotation de 180°.
\par              */ 
\par             \b0\cb3\cf14\b virtual void \b0\cb3\cf16\b reverse\b0\cb3\cf25 ();
\par             
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Méthode permettant de faire la rotation d'un objet par rapport à l'un de ses sommets.
\par              *
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b angle : Angle de la rotation.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b n : Numéro du sommet dans un objet shape qui sera le centre de la rotation.
\par              */ 
\par             \b0\cb3\cf14\b void \b0\cb1\cf0 rotateHW\cb3\cf25 (\cb3\cf14\b int \b0\cb1\cf0 angle\cb3\cf25 , \cb3\cf14\b unsigned int \b0\cb1\cf0 n\cb3\cf25 );
\par             
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Seter de la class geometricShape.
\par              *
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b pXnew : Nouvelle ensemble de coordonnée en x.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b pYnew : Nouvelle ensemble de coordonnée en x.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b cnew : Nouveau centre.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b scnew : Nouvelle taille de coté.
\par              */ 
\par             \b0\cb3\cf14\b void \b0\cb1\cf0 setShape\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > &\cb1\cf0 pXnew\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > &\cb1\cf0 pYnew\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > &\cb1\cf0 cnew\cb3\cf25 , \cb3\cf14\b double \b0\cb3\cf25 &\cb1\cf0 scnew\cb3\cf25 );
\par              
\par 
\par         \cb3\cf14\b protected\b0\cb3\cf25 :
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Geter pour sizeCote de la class geometricShape.
\par              *
\par              *  Renvoie la taille du coté de construction de la forme.
\par              */ 
\par             \b0\cb3\cf14\b double \b0\cb1\cf0 getSizeCote\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Geter pour px la class geometricShape
\par              *
\par              *  Renvoie les coordonnées en x de la figure
\par              */ 
\par             \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 getPx\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Geter pour py de la class geometricShape.
\par              *
\par              *  Renvoie les coordonnées en y de la figure.
\par              */ 
\par             \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 getPy\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Geter pour center la class geometricShape.
\par              *
\par              *  Renvoie les coordonnées du centre de la figure.
\par              */ 
\par             \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 getCenter\cb3\cf25 () \cb3\cf14\b const\b0\cb3\cf25 ;
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Méthode permettant de faire la rotation d'un objet par rapport à son centre.
\par              *
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b angle : Angle de la rotation.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b x : Position en x de la souris.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b y : Position en y de la souris.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b x0 : Position de la souris en x à n-1 ( pour obtenir deux vecteurs).
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b y0 : Position de la souris en y à n-1 ( pour obtenir deux vecteurs).
\par              */ 
\par             \b0\cb3\cf14\b void \b0\cb1\cf0 rotateCenter\cb3\cf25 (\cb3\cf14\b int \b0\cb1\cf0 angle\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 x \cb3\cf25 = \cb3\cf12 0\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 y \cb3\cf25 = \cb3\cf12 0\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 x0 \cb3\cf25 = \cb3\cf12 0\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 y0 \cb3\cf25 = \cb3\cf12 0\cb3\cf25 );
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Méthode permettant de faire la translation d'un objet.
\par              *
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b x : Position en x de la souris.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b y : Position en y de la souris.
\par              */ 
\par             \b0\cb3\cf14\b void \b0\cb1\cf0 translate\cb3\cf25 (\cb3\cf14\b int \b0\cb1\cf0 x\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 y\cb3\cf25 );
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Foncteur de la méthode translate qui réalise donc la translation d'un objet.
\par              *
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b x : Position en x de la souris.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b y : Position en y de la souris.
\par              */ 
\par             \b0\cb3\cf14\b void operator\b0\cb3\cf25 ()(\cb3\cf14\b int \b0\cb1\cf0 x\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 y\cb3\cf25 );
\par 
\par 
\par             \cb3\cf6\b /*!
\par              *  \b0\cb3\cf8 \\brief \cb3\cf6\b Test si deux objets peuvent être magnétisé.
\par              *
\par              *  Test si l'objet en praramètre et l'objet courant sont égal. 
\par              *  Si le test est vrai alors l'objet Shape en paramètre prend la valeur de l'objet courant.
\par              *  Renvoie un booléen pour savoir si le magnétisme à eu lieu.
\par              *  \b0\cb3\cf8 \\param \cb3\cf6\b s2 : Objet à tester et à modifier si les test est vrai.
\par              */ 
\par             \b0\cb3\cf14\b bool  \b0\cb1\cf0 magnetisme\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 Shape \cb3\cf25 &\cb1\cf0 s2\cb3\cf25 ) ;
\par 
\par             \cb3\cf14\b bool \b0\cb1\cf0 isRevert \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ; \cb3\cf6\b /*!< Booléen pour savoir si une symétrie à été effectuée.*/
\par                 
\par         \b0\cb3\cf14\b private\b0\cb3\cf25 :        
\par             \cb3\cf14\b double \b0\cb1\cf0 sizeCote\cb3\cf25 ; \cb3\cf6\b /*!< Taille du coté de la forme.*/
\par             \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 px\cb3\cf25 ; \cb3\cf6\b /*!< Coordonnées en x.*/
\par             \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 py\cb3\cf25 ; \cb3\cf6\b /*!< Coordonnées en y.*/
\par             \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 center\cb3\cf25 ; \cb3\cf6\b /*!< Coordonnées du centre.*/
\par     \b0\cb3\cf25 \};
\par     \cb3\cf14\b void \b0\cb1\cf0 drawAllShapes\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectShapes\cb3\cf25 , \cb1\cf0 MLV_Color colorShape\cb3\cf25 , \cb1\cf0 MLV_Color colorBorder\cb3\cf25 );
\par     \cb3\cf14\b void \b0\cb1\cf0 drawAllShapes\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectShapes\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > \cb1\cf0 colorShapes\cb3\cf25 , \cb1\cf0 MLV_Color colorBorder\cb3\cf25 );
\par   \cb3\cf4 //  bool operator == (const std::vector<std::shared_ptr<geometricShape::Shape>> &vectShapes, const std::vector<std::shared_ptr<geometricShape::Shape>> &vectModel) ;
\par     \cb3\cf14\b bool \b0\cb1\cf0 areEqual\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectShapes\cb3\cf25 , \cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectModel\cb3\cf25 );
\par     \cb3\cf14\b void \b0\cb1\cf0 saveDraw\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 fig\cb3\cf25 );  
\par     \cb3\cf14\b bool \b0\cb1\cf0 isInsideBoard\cb3\cf25 (\cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 x\cb3\cf25 , \cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 y\cb3\cf25 , \cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 with \cb3\cf25 = \cb3\cf12 1350\cb3\cf25 , \cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 heigth \cb3\cf25 = \cb3\cf12 700\cb3\cf25 );   
\par \}
\par \cb3\cf6\b /*!
\par  *  \b0\cb3\cf8 \\brief \cb3\cf6\b Surcharge du flux de sortie.
\par  *
\par  *  Fait appel à la méthode virtuel display .
\par  */ 
\par \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 ostream \cb3\cf25 &\cb3\cf14\b operator\b0\cb3\cf25 <<(\cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 ostream \cb3\cf25 &\cb1\cf0 os\cb3\cf25 , \cb3\cf14\b const \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape \cb3\cf25 &\cb1\cf0 tr\cb3\cf25 );
\par 
\par \cb3\cf16 #endif \cb3\cf4 // SHAPE_H
\par }