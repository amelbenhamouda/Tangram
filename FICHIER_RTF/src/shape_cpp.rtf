{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red200\green200\blue200;\red0\green0\blue0;\red152\green152\blue217;\red192\green192\blue192;\red128\green128\blue255;\red170\green170\blue240;\red0\green128\blue128;\red107\green153\blue153;\red128\green0\blue0;\red172\green89\blue89;\red240\green0\blue240;\red240\green200\blue240;\red0\green0\blue160;\red135\green135\blue200;\red0\green160\blue0;\red154\green200\blue154;\red190\green0\blue190;\red190\green137\blue190;\red0\green0\blue255;\red190\green190\blue255;\red224\green160\blue0;\red224\green206\blue159;\red132\green160\blue132;\red255\green0\blue0;\red255\green200\blue200;\red64\green64\blue128;\red133\green133\blue172;\red128\green255\blue255;\red55\green55\blue55;}
{\info{\comment Generated by the Code::Blocks RTF Exporter plugin}
{\title Untitled}}

\deflang1033\pard\plain\f0\fs20 \cb1\cf0 
\par \cb3\cf16 #include "../include/shape.hpp"
\par #include "../include/board.hpp"
\par #include <cmath>
\par #include <assert.h> 
\par #include <fstream>
\par #include <iostream>
\par #include <string>
\par 
\par \cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::~\cb1\cf0 Shape\cb3\cf25 () \{\}
\par 
\par \cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape \cb3\cf25 & \cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb3\cf14\b operator\b0\cb3\cf25 =(\cb3\cf14\b const \b0\cb1\cf0 Shape \cb3\cf25 & \cb1\cf0 tc\cb3\cf25 ) \{
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb3\cf14\b this \b0\cb3\cf25 == &\cb1\cf0 tc\cb3\cf25 )\{
\par         \cb3\cf14\b return \b0\cb3\cf25 *\cb3\cf14\b this\b0\cb3\cf25 ;
\par     \}
\par 
\par     \cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape \cb3\cf16\b copy\b0\cb3\cf25 (\cb1\cf0 tc\cb3\cf25 );
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b swap\b0\cb3\cf25 (\cb1\cf0 sizeCote\cb3\cf25 , \cb3\cf16\b copy\b0\cb3\cf25 .\cb1\cf0 sizeCote\cb3\cf25 );
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b swap\b0\cb3\cf25 (\cb1\cf0 px\cb3\cf25 , \cb3\cf16\b copy\b0\cb3\cf25 .\cb1\cf0 px\cb3\cf25 );
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b swap\b0\cb3\cf25 (\cb1\cf0 py\cb3\cf25 , \cb3\cf16\b copy\b0\cb3\cf25 .\cb1\cf0 py\cb3\cf25 );
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b swap\b0\cb3\cf25 (\cb1\cf0 center\cb3\cf25 , \cb3\cf16\b copy\b0\cb3\cf25 .\cb1\cf0 center\cb3\cf25 );
\par     \cb3\cf14\b return \b0\cb3\cf25 *\cb3\cf14\b this\b0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b bool \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb3\cf14\b operator\b0\cb3\cf25 ==(\cb3\cf14\b const \b0\cb1\cf0 Shape \cb3\cf25 & \cb1\cf0 s\cb3\cf25 ) \cb3\cf14\b const \b0\cb3\cf25 \{
\par     \cb3\cf14\b bool \b0\cb1\cf0 ret \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ;
\par     \cb3\cf14\b double \b0\cb1\cf0 thresh \cb3\cf25 = \cb1\cf0 round\cb3\cf25 (\cb1\cf0 sizeCote \cb3\cf25 * \cb3\cf12 0.2\cb3\cf25 );
\par     \cb3\cf14\b unsigned int \b0\cb1\cf0 nbequal \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 () != \cb1\cf0 s\cb3\cf25 .\cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 ()) \{
\par         \cb3\cf14\b return false\b0\cb3\cf25 ;
\par     \}
\par     
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b unsigned int \b0\cb1\cf0 i \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i \cb3\cf25 < \cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 (); \cb1\cf0 i\cb3\cf25 ++) \{
\par         \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b unsigned int \b0\cb1\cf0 j \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 j \cb3\cf25 < \cb1\cf0 s\cb3\cf25 .\cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 (); \cb1\cf0 j\cb3\cf25 ++) \{
\par             \cb3\cf14\b if \b0\cb3\cf25 ((\cb1\cf0 px\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] <= \cb1\cf0 s\cb3\cf25 .\cb1\cf0 px\cb3\cf25 [\cb1\cf0 j\cb3\cf25 ] + \cb1\cf0 thresh\cb3\cf25 ) && (\cb1\cf0 px\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] >= \cb1\cf0 s\cb3\cf25 .\cb1\cf0 px\cb3\cf25 [\cb1\cf0 j\cb3\cf25 ] - \cb1\cf0 thresh\cb3\cf25 ) && (\cb1\cf0 py\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] <= \cb1\cf0 s\cb3\cf25 .\cb1\cf0 py\cb3\cf25 [\cb1\cf0 j\cb3\cf25 ] + \cb1\cf0 thresh\cb3\cf25 ) && (\cb1\cf0 py\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] >= \cb1\cf0 s\cb3\cf25 .\cb1\cf0 py\cb3\cf25 [\cb1\cf0 j\cb3\cf25 ] - \cb1\cf0 thresh\cb3\cf25 )) \{
\par                 \cb1\cf0 nbequal\cb3\cf25 ++;
\par             \}
\par         \}
\par     \}
\par     \cb3\cf14\b if \b0\cb3\cf25 ((\cb1\cf0 nbequal \cb3\cf25 == \cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 ()) && (\cb1\cf0 sizeCote \cb3\cf25 == \cb1\cf0 s\cb3\cf25 .\cb1\cf0 sizeCote\cb3\cf25 )) \{
\par         \cb1\cf0 ret \cb3\cf25 = \cb3\cf14\b true\b0\cb3\cf25 ;
\par     \}
\par     \cb3\cf14\b return \b0\cb1\cf0 ret\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b bool  \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 magnetisme\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 Shape \cb3\cf25 &\cb1\cf0 s2\cb3\cf25 ) \{
\par     \cb3\cf14\b if\b0\cb3\cf25 (*\cb3\cf14\b this\b0\cb3\cf25 ==\cb1\cf0 s2\cb3\cf25 )\{
\par         *\cb3\cf14\b this\b0\cb3\cf25 =\cb1\cf0 s2 \cb3\cf25 ;
\par         \cb3\cf14\b return true\b0\cb3\cf25 ;
\par     \}
\par     \cb3\cf14\b return false\b0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b bool \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 areEqual\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectShapes\cb3\cf25 , \cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectModel\cb3\cf25 ) \{
\par     \cb3\cf14\b unsigned int \b0\cb3\cf16\b count \b0\cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par     \cb3\cf14\b bool \b0\cb1\cf0 ret \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ;
\par 
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 vectShapes\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 () == \cb1\cf0 vectModel\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 ()) \{
\par         \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b auto \b0\cb1\cf0 shap_it \cb3\cf25 : \cb1\cf0 vectShapes\cb3\cf25 ) \{
\par             \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b auto \b0\cb1\cf0 model_it \cb3\cf25 : \cb1\cf0 vectModel\cb3\cf25 ) \{
\par                 \cb3\cf14\b bool \b0\cb1\cf0 loc \cb3\cf25 = (*\cb1\cf0 shap_it \cb3\cf25 == *\cb1\cf0 model_it\cb3\cf25 );
\par                 \cb1\cf0 ret \cb3\cf25 = \cb1\cf0 loc\cb3\cf25 ;
\par                 \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 loc \cb3\cf25 == \cb3\cf14\b true\b0\cb3\cf25 ) \{
\par                     \cb3\cf16\b count\b0\cb3\cf25 ++;
\par                 \}
\par             \}
\par         \}
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb3\cf16\b count \b0\cb3\cf25 == \cb1\cf0 vectShapes\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 ()) \{
\par             \cb1\cf0 ret \cb3\cf25 = \cb3\cf14\b true\b0\cb3\cf25 ;
\par         \}
\par         \cb3\cf14\b else \b0\cb3\cf25 \{
\par             \cb1\cf0 ret \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ;
\par         \}
\par     \}
\par     \cb3\cf14\b return \b0\cb1\cf0 ret\cb3\cf25 ; 
\par \}
\par                 
\par \cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 (\cb3\cf14\b const \b0\cb1\cf0 Shape \cb3\cf25 & \cb1\cf0 tc\cb3\cf25 ) : \cb1\cf0 sizeCote\cb3\cf25 (\cb1\cf0 tc\cb3\cf25 .\cb1\cf0 sizeCote\cb3\cf25 ), \cb1\cf0 px\cb3\cf25 (\cb1\cf0 tc\cb3\cf25 .\cb1\cf0 px\cb3\cf25 ), \cb1\cf0 py\cb3\cf25 (\cb1\cf0 tc\cb3\cf25 .\cb1\cf0 py\cb3\cf25 ), \cb1\cf0 center\cb3\cf25 (\cb1\cf0 tc\cb3\cf25 .\cb1\cf0 center\cb3\cf25 ) \{\}
\par 
\par \cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 (\cb3\cf14\b double \b0\cb1\cf0 sizeCote\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 width\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 height\cb3\cf25 ) : \cb1\cf0 sizeCote\cb3\cf25 (\cb1\cf0 sizeCote\cb3\cf25 ), \cb1\cf0 px\cb3\cf25 (\cb3\cf12 0\cb3\cf25 ), \cb1\cf0 py\cb3\cf25 (\cb3\cf12 0\cb3\cf25 ), \cb1\cf0 center\cb3\cf25 (\cb3\cf12 0\cb3\cf25 ) \{\}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 setShape\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > &\cb1\cf0 pXnew\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > &\cb1\cf0 pYnew\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > &\cb1\cf0 cnew\cb3\cf25 , \cb3\cf14\b double \b0\cb3\cf25 &\cb1\cf0 scnew\cb3\cf25 ) \{
\par     \cb1\cf0 sizeCote \cb3\cf25 = \cb1\cf0 scnew\cb3\cf25 ;
\par     \cb1\cf0 px \cb3\cf25 = \cb1\cf0 pXnew\cb3\cf25 ;
\par     \cb1\cf0 py \cb3\cf25 = \cb1\cf0 pYnew\cb3\cf25 ;
\par     \cb1\cf0 center \cb3\cf25 = \cb1\cf0 cnew\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b double \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 getSizeCote\cb3\cf25 () \cb3\cf14\b const \b0\cb3\cf25 \{
\par     \cb3\cf14\b return \b0\cb1\cf0 sizeCote\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 getPx\cb3\cf25 () \cb3\cf14\b const \b0\cb3\cf25 \{
\par     \cb3\cf14\b return \b0\cb1\cf0 px\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 getPy\cb3\cf25 () \cb3\cf14\b const \b0\cb3\cf25 \{
\par     \cb3\cf14\b return \b0\cb1\cf0 py\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 getCenter\cb3\cf25 () \cb3\cf14\b const \b0\cb3\cf25 \{
\par     \cb3\cf14\b return \b0\cb1\cf0 center\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 draw\cb3\cf25 (\cb1\cf0 MLV_Color colorShape\cb3\cf25 , \cb1\cf0 MLV_Color colorBorder\cb3\cf25 ) \cb3\cf14\b const \b0\cb3\cf25 \{
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b int\b0\cb3\cf25 > \cb1\cf0 pxDraw\cb3\cf25 ;
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b int\b0\cb3\cf25 > \cb1\cf0 pyDraw\cb3\cf25 ;
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b unsigned int \b0\cb1\cf0 i \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i \cb3\cf25 < \cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 (); \cb1\cf0 i\cb3\cf25 ++) \{
\par         \cb1\cf0 pxDraw\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 floor\cb3\cf25 (\cb1\cf0 px\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] + \cb3\cf12 0.5\cb3\cf25 ));
\par         \cb1\cf0 pyDraw\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 floor\cb3\cf25 (\cb1\cf0 py\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] + \cb3\cf12 0.5\cb3\cf25 ));
\par     \}
\par     \cb1\cf0 MLV_draw_filled_polygon\cb3\cf25 (\cb1\cf0 pxDraw\cb3\cf25 .\cb1\cf0 data\cb3\cf25 (), \cb1\cf0 pyDraw\cb3\cf25 .\cb1\cf0 data\cb3\cf25 (), \cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 (), \cb1\cf0 colorShape\cb3\cf25 );
\par     \cb1\cf0 MLV_draw_polygon\cb3\cf25 (\cb1\cf0 pxDraw\cb3\cf25 .\cb1\cf0 data\cb3\cf25 (), \cb1\cf0 pyDraw\cb3\cf25 .\cb1\cf0 data\cb3\cf25 (), \cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 (), \cb1\cf0 colorBorder\cb3\cf25 );
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 drawAllShapes\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectShapes\cb3\cf25 , \cb1\cf0 MLV_Color colorShape\cb3\cf25 , \cb1\cf0 MLV_Color colorBorder\cb3\cf25 ) \{
\par     \cb3\cf14\b for\b0\cb3\cf25 (\cb3\cf14\b auto \b0\cb1\cf0 it \cb3\cf25 : \cb1\cf0 vectShapes\cb3\cf25 )\{
\par         \cb1\cf0 it\cb3\cf25 ->\cb1\cf0 draw\cb3\cf25 (\cb1\cf0 colorShape\cb3\cf25 , \cb1\cf0 colorBorder\cb3\cf25 );
\par     \}
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 drawAllShapes\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 vectShapes\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > \cb1\cf0 colorShapes\cb3\cf25 , \cb1\cf0 MLV_Color colorBorder\cb3\cf25 ) \{
\par     \cb3\cf14\b auto \b0\cb1\cf0 itcolor \cb3\cf25 = \cb1\cf0 colorShapes\cb3\cf25 .\cb3\cf16\b begin\b0\cb3\cf25 ();
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b auto \b0\cb1\cf0 it \cb3\cf25 : \cb1\cf0 vectShapes\cb3\cf25 ) \{
\par         \cb1\cf0 it\cb3\cf25 ->\cb1\cf0 draw\cb3\cf25 (*\cb1\cf0 itcolor\cb3\cf25 , \cb1\cf0 colorBorder\cb3\cf25 );
\par         \cb1\cf0 itcolor\cb3\cf25 ++;
\par     \}
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 rotateHW\cb3\cf25 (\cb3\cf14\b int \b0\cb1\cf0 angle\cb3\cf25 , \cb3\cf14\b unsigned int \b0\cb1\cf0 n\cb3\cf25 ) \{       
\par     \cb1\cf0 assert\cb3\cf25 (\cb1\cf0 n \cb3\cf25 <= \cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 () && \cb1\cf0 n \cb3\cf25 >= \cb3\cf12 0\cb3\cf25 );
\par     \cb3\cf14\b double \b0\cb1\cf0 pivoX \cb3\cf25 = \cb1\cf0 px\cb3\cf25 [\cb1\cf0 n\cb3\cf25 ];
\par     \cb3\cf14\b double \b0\cb1\cf0 pivoY \cb3\cf25 = \cb1\cf0 py\cb3\cf25 [\cb1\cf0 n\cb3\cf25 ];
\par     \cb3\cf14\b double \b0\cb1\cf0 angleRad \cb3\cf25 = (\cb3\cf14\b double\b0\cb3\cf25 ) \cb1\cf0 angle \cb3\cf25 * \cb1\cf0 PI \cb3\cf25 / \cb3\cf12 180\cb3\cf25 ;
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b unsigned int \b0\cb1\cf0 it \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 it \cb3\cf25 < \cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 (); \cb1\cf0 it\cb3\cf25 ++) \{
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 it \cb3\cf25 != \cb1\cf0 n\cb3\cf25 ) \{
\par             \cb3\cf14\b double \b0\cb1\cf0 xM \cb3\cf25 = \cb1\cf0 px\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ] - \cb1\cf0 pivoX\cb3\cf25 ;
\par             \cb3\cf14\b double \b0\cb1\cf0 yM \cb3\cf25 = \cb1\cf0 py\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ] - \cb1\cf0 pivoY\cb3\cf25 ;
\par             \cb1\cf0 px\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ] = \cb1\cf0 xM \cb3\cf25 * \cb1\cf0 cos\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 ) + \cb1\cf0 yM \cb3\cf25 * \cb1\cf0 sin\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 ) + \cb1\cf0 pivoX\cb3\cf25 ; 
\par             \cb1\cf0 py\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ] = -\cb1\cf0 xM \cb3\cf25 * \cb1\cf0 sin\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 ) + \cb1\cf0 yM \cb3\cf25 * \cb1\cf0 cos\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 ) + \cb1\cf0 pivoY\cb3\cf25 ;
\par         \}
\par     \}
\par     \cb3\cf14\b double \b0\cb1\cf0 xM \cb3\cf25 = \cb1\cf0 center\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ] - \cb1\cf0 pivoX\cb3\cf25 ;
\par     \cb3\cf14\b double \b0\cb1\cf0 yM \cb3\cf25 = \cb1\cf0 center\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ] - \cb1\cf0 pivoY\cb3\cf25 ;
\par     \cb1\cf0 center\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ] = \cb1\cf0 xM \cb3\cf25 * \cb1\cf0 cos\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 ) + \cb1\cf0 yM \cb3\cf25 * \cb1\cf0 sin\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 ) + \cb1\cf0 pivoX\cb3\cf25 ;
\par     \cb1\cf0 center\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ] = -\cb1\cf0 xM \cb3\cf25 * \cb1\cf0 sin\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 ) + \cb1\cf0 yM \cb3\cf25 * \cb1\cf0 cos\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 ) + \cb1\cf0 pivoY\cb3\cf25 ;
\par \} 
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 rotateCenter\cb3\cf25 (\cb3\cf14\b int \b0\cb1\cf0 angle\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 x\cb3\cf25 ,\cb3\cf14\b int \b0\cb1\cf0 y\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 x0\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 y0\cb3\cf25 ) \{   
\par     \cb3\cf14\b double \b0\cb1\cf0 angleRad\cb3\cf25 ;
\par     \cb3\cf14\b if \b0\cb3\cf25 ((\cb1\cf0 x \cb3\cf25 != \cb3\cf12 0\cb3\cf25 ) && (\cb1\cf0 y \cb3\cf25 != \cb3\cf12 0\cb3\cf25 ) && \cb1\cf0 x \cb3\cf25 != \cb1\cf0 x0 \cb3\cf25 && \cb1\cf0 y \cb3\cf25 != \cb1\cf0 y0\cb3\cf25 ) \{
\par         \cb3\cf14\b double \b0\cb1\cf0 Ux \cb3\cf25 = \cb1\cf0 x \cb3\cf25 - \cb1\cf0 center\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ];
\par         \cb3\cf14\b double \b0\cb1\cf0 Uy \cb3\cf25 = \cb1\cf0 y \cb3\cf25 - \cb1\cf0 center\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ];
\par         \cb3\cf14\b double \b0\cb1\cf0 Vx \cb3\cf25 = \cb1\cf0 x0 \cb3\cf25 - \cb1\cf0 center\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ];
\par         \cb3\cf14\b double \b0\cb1\cf0 Vy \cb3\cf25 = \cb1\cf0 y0 \cb3\cf25 - \cb1\cf0 center\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ];
\par         \cb3\cf14\b double \b0\cb1\cf0 normU \cb3\cf25 = \cb1\cf0 sqrt\cb3\cf25 (\cb1\cf0 pow\cb3\cf25 (\cb1\cf0 Ux\cb3\cf25 , \cb3\cf12 2\cb3\cf25 ) + \cb1\cf0 pow\cb3\cf25 (\cb1\cf0 Uy\cb3\cf25 , \cb3\cf12 2\cb3\cf25 ));
\par         \cb3\cf14\b double \b0\cb1\cf0 normV \cb3\cf25 = \cb1\cf0 sqrt\cb3\cf25 (\cb1\cf0 pow\cb3\cf25 (\cb1\cf0 Vx\cb3\cf25 , \cb3\cf12 2\cb3\cf25 ) + \cb1\cf0 pow\cb3\cf25 (\cb1\cf0 Vy\cb3\cf25 , \cb3\cf12 2\cb3\cf25 ));
\par         \cb3\cf14\b double \b0\cb1\cf0 distUV \cb3\cf25 = \cb1\cf0 sqrt\cb3\cf25 (\cb1\cf0 pow\cb3\cf25 (\cb1\cf0 x \cb3\cf25 - \cb1\cf0 x0\cb3\cf25 , \cb3\cf12 2\cb3\cf25 ) + \cb1\cf0 pow\cb3\cf25 (\cb1\cf0 y \cb3\cf25 - \cb1\cf0 y0\cb3\cf25 , \cb3\cf12 2\cb3\cf25 ));
\par         \cb3\cf14\b int \b0\cb1\cf0 det \cb3\cf25 = \cb1\cf0 Ux \cb3\cf25 * \cb1\cf0 Vy \cb3\cf25 - \cb1\cf0 Uy \cb3\cf25 * \cb1\cf0 Vx\cb3\cf25 ;
\par         \cb1\cf0 angleRad \cb3\cf25 = \cb3\cf12 0.5 \cb3\cf25 * (\cb1\cf0 pow\cb3\cf25 (\cb1\cf0 normU\cb3\cf25 , \cb3\cf12 2\cb3\cf25 ) + \cb1\cf0 pow\cb3\cf25 (\cb1\cf0 normV\cb3\cf25 , \cb3\cf12 2\cb3\cf25 ) - \cb1\cf0 pow\cb3\cf25 (\cb1\cf0 distUV\cb3\cf25 , \cb3\cf12 2\cb3\cf25 ));
\par         \cb1\cf0 angleRad \cb3\cf25 = \cb1\cf0 acos\cb3\cf25 (\cb1\cf0 angleRad \cb3\cf25 / (\cb1\cf0 normU \cb3\cf25 * \cb1\cf0 normV\cb3\cf25 ));
\par         \cb1\cf0 angleRad \cb3\cf25 = \cb1\cf0 copysign\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 , \cb1\cf0 det\cb3\cf25 );
\par     \}
\par     \cb3\cf14\b else \b0\cb3\cf25 \{
\par         \cb1\cf0 angleRad \cb3\cf25 = (\cb3\cf14\b double\b0\cb3\cf25 ) \cb1\cf0 angle \cb3\cf25 * \cb1\cf0 PI \cb3\cf25 / \cb3\cf12 180\cb3\cf25 ;
\par     \}
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 pxloc \cb3\cf25 = \cb1\cf0 px\cb3\cf25 ;
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 pyloc \cb3\cf25 = \cb1\cf0 py\cb3\cf25 ; 
\par     \cb3\cf14\b bool \b0\cb1\cf0 inside \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ;
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b unsigned int \b0\cb1\cf0 it \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 it \cb3\cf25 < \cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 (); \cb1\cf0 it\cb3\cf25 ++) \{
\par         \cb3\cf14\b double \b0\cb1\cf0 xM \cb3\cf25 = \cb1\cf0 pxloc\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ] - \cb1\cf0 center\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ];
\par         \cb3\cf14\b double \b0\cb1\cf0 yM \cb3\cf25 = \cb1\cf0 pyloc\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ] - \cb1\cf0 center\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ];
\par         \cb1\cf0 pxloc\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ] = \cb1\cf0 xM \cb3\cf25 * \cb1\cf0 cos\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 ) + \cb1\cf0 yM \cb3\cf25 * \cb1\cf0 sin\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 ) + \cb1\cf0 center\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ];   \cb3\cf4 /* [cos(0) -sin(0); sin(0) cos(0)]*/
\par         \cb1\cf0 pyloc\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ] = -\cb1\cf0 xM \cb3\cf25 * \cb1\cf0 sin\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 ) + \cb1\cf0 yM \cb3\cf25 * \cb1\cf0 cos\cb3\cf25 (\cb1\cf0 angleRad\cb3\cf25 ) + \cb1\cf0 center\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ];
\par         \cb1\cf0 inside \cb3\cf25 = \cb1\cf0 isInsideBoard\cb3\cf25 (\cb1\cf0 pxloc\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ], \cb1\cf0 pyloc\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ]);
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 inside \cb3\cf25 == \cb3\cf12 0\cb3\cf25 ) \{
\par             \cb3\cf14\b break\b0\cb3\cf25 ;
\par         \}
\par     \}
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 inside \cb3\cf25 == \cb3\cf14\b true\b0\cb3\cf25 ) \{
\par         \cb1\cf0 px \cb3\cf25 = \cb1\cf0 pxloc\cb3\cf25 ;
\par         \cb1\cf0 py \cb3\cf25 = \cb1\cf0 pyloc\cb3\cf25 ;
\par     \}
\par \} 
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 translate\cb3\cf25 (\cb3\cf14\b int \b0\cb1\cf0 x\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 y\cb3\cf25 ) \{
\par     \cb3\cf4 // translation de l'objet en fonction de la position x,y de la souris
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 pxloc \cb3\cf25 = \cb1\cf0 px\cb3\cf25 ;
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 pyloc \cb3\cf25 = \cb1\cf0 py\cb3\cf25 ; 
\par     \cb3\cf14\b bool \b0\cb1\cf0 inside \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ;
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b unsigned int \b0\cb1\cf0 it \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 it \cb3\cf25 < \cb1\cf0 pxloc\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 (); \cb1\cf0 it\cb3\cf25 ++) \{
\par         \cb1\cf0 pxloc\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ] += \cb1\cf0 x\cb3\cf25 ;
\par         \cb1\cf0 pyloc\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ] += \cb1\cf0 y\cb3\cf25 ;
\par         \cb1\cf0 inside \cb3\cf25 = \cb1\cf0 isInsideBoard\cb3\cf25 (\cb1\cf0 pxloc\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ], \cb1\cf0 pyloc\cb3\cf25 [\cb1\cf0 it\cb3\cf25 ]);
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 inside \cb3\cf25 == \cb3\cf14\b false\b0\cb3\cf25 ) \{
\par             \cb3\cf14\b break\b0\cb3\cf25 ;
\par         \}
\par     \}
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 inside \cb3\cf25 == \cb3\cf14\b true\b0\cb3\cf25 ) \{
\par         \cb1\cf0 px \cb3\cf25 = \cb1\cf0 pxloc\cb3\cf25 ;
\par         \cb1\cf0 py \cb3\cf25 = \cb1\cf0 pyloc\cb3\cf25 ;
\par         \cb1\cf0 center\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ] += \cb1\cf0 x\cb3\cf25 ;
\par         \cb1\cf0 center\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ] += \cb1\cf0 y\cb3\cf25 ;
\par     \}
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb3\cf14\b operator\b0\cb3\cf25 ()(\cb3\cf14\b int \b0\cb1\cf0 x\cb3\cf25 , \cb3\cf14\b int \b0\cb1\cf0 y\cb3\cf25 ) \{
\par     \cb1\cf0 translate\cb3\cf25 (\cb1\cf0 x\cb3\cf25 , \cb1\cf0 y\cb3\cf25 );
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb3\cf16\b reverse\b0\cb3\cf25 () \{
\par     \cb1\cf0 rotateCenter\cb3\cf25 (\cb3\cf12 180\cb3\cf25 );
\par     \cb1\cf0 MLV_wait_milliseconds\cb3\cf25 (\cb3\cf12 500\cb3\cf25 );
\par \}
\par 
\par \cb3\cf14\b bool \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 isInside\cb3\cf25 (\cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 x\cb3\cf25 , \cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 y\cb3\cf25 ) \cb3\cf14\b const \b0\cb3\cf25 \{
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b unsigned int \b0\cb1\cf0 i \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i \cb3\cf25 < \cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 (); \cb1\cf0 i\cb3\cf25 ++) \{
\par         \cb3\cf14\b int \b0\cb1\cf0 Ax \cb3\cf25 = \cb1\cf0 px\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ];
\par         \cb3\cf14\b int \b0\cb1\cf0 Ay \cb3\cf25 = \cb1\cf0 py\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ];
\par         \cb3\cf14\b int \b0\cb1\cf0 Bx\cb3\cf25 , \cb1\cf0 By\cb3\cf25 ;
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 i \cb3\cf25 == \cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 () - \cb3\cf12 1\cb3\cf25 ) \{  \cb3\cf4 // if i == last point of vector px then B == first point
\par             \cb1\cf0 Bx \cb3\cf25 = \cb1\cf0 px\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ];
\par             \cb1\cf0 By \cb3\cf25 = \cb1\cf0 py\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ];
\par         \}
\par         \cb3\cf14\b else \b0\cb3\cf25 \{ \cb3\cf4 // else B take the point at i+1
\par             \cb1\cf0 Bx \cb3\cf25 = \cb1\cf0 px\cb3\cf25 [\cb1\cf0 i \cb3\cf25 + \cb3\cf12 1\cb3\cf25 ];
\par             \cb1\cf0 By \cb3\cf25 = \cb1\cf0 py\cb3\cf25 [\cb1\cf0 i \cb3\cf25 + \cb3\cf12 1\cb3\cf25 ];
\par         \}
\par         \cb3\cf14\b double \b0\cb1\cf0 Dx\cb3\cf25 , \cb1\cf0 Dy\cb3\cf25 , \cb1\cf0 Tx\cb3\cf25 , \cb1\cf0 Ty\cb3\cf25 ;
\par         \cb1\cf0 Dx \cb3\cf25 = \cb1\cf0 Bx \cb3\cf25 - \cb1\cf0 Ax\cb3\cf25 ;
\par         \cb1\cf0 Dy \cb3\cf25 = \cb1\cf0 By \cb3\cf25 - \cb1\cf0 Ay\cb3\cf25 ;
\par         \cb1\cf0 Tx \cb3\cf25 = \cb1\cf0 x \cb3\cf25 - \cb1\cf0 Ax\cb3\cf25 ;
\par         \cb1\cf0 Ty \cb3\cf25 = \cb1\cf0 y \cb3\cf25 - \cb1\cf0 Ay\cb3\cf25 ;
\par         \cb3\cf14\b double \b0\cb1\cf0 d \cb3\cf25 = \cb1\cf0 Dx \cb3\cf25 * \cb1\cf0 Ty \cb3\cf25 - \cb1\cf0 Dy \cb3\cf25 * \cb1\cf0 Tx\cb3\cf25 ;
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 d \cb3\cf25 < \cb3\cf12 0\cb3\cf25 ) \{
\par             \cb3\cf14\b return false\b0\cb3\cf25 ;  \cb3\cf4 // Point (x,y) is not inside.
\par         \cb3\cf25 \}
\par     \}
\par     \cb3\cf14\b return true\b0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b bool \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 isInsideBoard\cb3\cf25 (\cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 x\cb3\cf25 , \cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 y\cb3\cf25 , \cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 width\cb3\cf25 , \cb3\cf14\b const int \b0\cb3\cf25 &\cb1\cf0 heigth\cb3\cf25 ) \{
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 Boardx\cb3\cf25 ;
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 Boardy\cb3\cf25 ;
\par     \cb1\cf0 Boardx\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf12 45\cb3\cf25 );
\par     \cb1\cf0 Boardx\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 width \cb3\cf25 - \cb3\cf12 270\cb3\cf25 );
\par     \cb1\cf0 Boardx\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 width \cb3\cf25 - \cb3\cf12 270\cb3\cf25 );
\par     \cb1\cf0 Boardx\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf12 45\cb3\cf25 );
\par 
\par     \cb1\cf0 Boardy\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf12 35\cb3\cf25 );
\par     \cb1\cf0 Boardy\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf12 35\cb3\cf25 );
\par     \cb1\cf0 Boardy\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 heigth \cb3\cf25 - \cb3\cf12 12\cb3\cf25 );
\par     \cb1\cf0 Boardy\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 heigth \cb3\cf25 - \cb3\cf12 12\cb3\cf25 );
\par 
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b unsigned int \b0\cb1\cf0 i \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i \cb3\cf25 < \cb1\cf0 Boardx\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 (); \cb1\cf0 i\cb3\cf25 ++) \{
\par         \cb3\cf14\b int \b0\cb1\cf0 Ax \cb3\cf25 = \cb1\cf0 Boardx\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ];
\par         \cb3\cf14\b int \b0\cb1\cf0 Ay \cb3\cf25 = \cb1\cf0 Boardy\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ];
\par         \cb3\cf14\b int \b0\cb1\cf0 Bx\cb3\cf25 , \cb1\cf0 By\cb3\cf25 ;
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 i \cb3\cf25 == \cb1\cf0 Boardx\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 () - \cb3\cf12 1\cb3\cf25 ) \{ \cb3\cf4 // if i== last point of vector px then B == first point
\par             \cb1\cf0 Bx \cb3\cf25 = \cb1\cf0 Boardx\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ];
\par             \cb1\cf0 By \cb3\cf25 = \cb1\cf0 Boardy\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ];
\par         \}
\par         \cb3\cf14\b else \b0\cb3\cf25 \{  \cb3\cf4 // else B take the point at i+1
\par             \cb1\cf0 Bx \cb3\cf25 = \cb1\cf0 Boardx\cb3\cf25 [\cb1\cf0 i \cb3\cf25 + \cb3\cf12 1\cb3\cf25 ];
\par             \cb1\cf0 By \cb3\cf25 = \cb1\cf0 Boardy\cb3\cf25 [\cb1\cf0 i \cb3\cf25 + \cb3\cf12 1\cb3\cf25 ];
\par         \}
\par         \cb3\cf14\b double \b0\cb1\cf0 Dx\cb3\cf25 , \cb1\cf0 Dy\cb3\cf25 , \cb1\cf0 Tx\cb3\cf25 , \cb1\cf0 Ty\cb3\cf25 ;
\par         \cb1\cf0 Dx \cb3\cf25 = \cb1\cf0 Bx \cb3\cf25 - \cb1\cf0 Ax\cb3\cf25 ;
\par         \cb1\cf0 Dy \cb3\cf25 = \cb1\cf0 By \cb3\cf25 - \cb1\cf0 Ay\cb3\cf25 ;
\par         \cb1\cf0 Tx \cb3\cf25 = \cb1\cf0 x \cb3\cf25 - \cb1\cf0 Ax\cb3\cf25 ;
\par         \cb1\cf0 Ty \cb3\cf25 = \cb1\cf0 y \cb3\cf25 - \cb1\cf0 Ay\cb3\cf25 ;
\par         \cb3\cf14\b double \b0\cb1\cf0 d \cb3\cf25 = \cb1\cf0 Dx \cb3\cf25 * \cb1\cf0 Ty \cb3\cf25 - \cb1\cf0 Dy \cb3\cf25 * \cb1\cf0 Tx\cb3\cf25 ;
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 d \cb3\cf25 < \cb3\cf12 0\cb3\cf25 ) \{
\par             \cb3\cf14\b return false\b0\cb3\cf25 ;  \cb3\cf4 // Point (x,y) is not inside.
\par         \cb3\cf25 \}
\par     \}
\par     \cb3\cf14\b return true\b0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 moveShape\cb3\cf25 (\cb3\cf14\b int \b0\cb3\cf25 &\cb1\cf0 xInside\cb3\cf25 , \cb3\cf14\b int \b0\cb3\cf25 &\cb1\cf0 yInside\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 fig\cb3\cf25 , 
\par                                     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 MLV_Color motifShape\cb3\cf25 , \cb1\cf0 MLV_Color motifBorder\cb3\cf25 , 
\par                                     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > &\cb1\cf0 colorfig\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 >::\cb3\cf16\b iterator \b0\cb1\cf0 fig_num\cb3\cf25 ,\cb1\cf0 Board \cb3\cf25 &\cb1\cf0 board\cb3\cf25 , \cb3\cf14\b bool \b0\cb3\cf25 &\cb1\cf0 wincondi\cb3\cf25 ) \{
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 isInside\cb3\cf25 (\cb1\cf0 xInside\cb3\cf25 , \cb1\cf0 yInside\cb3\cf25 ) == \cb3\cf12 1\cb3\cf25 ) \{ 
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 wincondi\cb3\cf25 )\{
\par             \cb1\cf0 board\cb3\cf25 .\cb1\cf0 drawBoard\cb3\cf25 ();
\par             \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par             \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 , \cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par         \}
\par 
\par         \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par         \cb3\cf14\b bool \b0\cb1\cf0 done \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ;
\par         \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > \cb1\cf0 colorfig_loc \cb3\cf25 = \cb1\cf0 colorfig\cb3\cf25 ;
\par         \cb1\cf0 Uint8 red\cb3\cf25 , \cb1\cf0 green\cb3\cf25 , \cb1\cf0 blue\cb3\cf25 , \cb1\cf0 alpha\cb3\cf25 ;
\par         \cb1\cf0 MLV_convert_color_to_rgba\cb3\cf25 (*\cb1\cf0 fig_num\cb3\cf25 , &\cb1\cf0 red\cb3\cf25 , &\cb1\cf0 green\cb3\cf25 , &\cb1\cf0 blue\cb3\cf25 , &\cb1\cf0 alpha\cb3\cf25 );
\par         \cb1\cf0 red \cb3\cf25 = \cb1\cf0 red \cb3\cf25 * \cb3\cf12 0.5\cb3\cf25 ;
\par         \cb1\cf0 green \cb3\cf25 = \cb1\cf0 green \cb3\cf25 * \cb3\cf12 0.5\cb3\cf25 ;
\par         \cb1\cf0 blue \cb3\cf25 = \cb1\cf0 blue \cb3\cf25 * \cb3\cf12 0.5\cb3\cf25 ;
\par         *\cb1\cf0 fig_num \cb3\cf25 = \cb1\cf0 MLV_convert_rgba_to_color\cb3\cf25 (\cb1\cf0 red\cb3\cf25 , \cb1\cf0 green\cb3\cf25 , \cb1\cf0 blue\cb3\cf25 , \cb1\cf0 alpha\cb3\cf25 );
\par 
\par         \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 done \cb3\cf25 != \cb3\cf14\b true\b0\cb3\cf25 ) \{
\par             \cb3\cf14\b int \b0\cb1\cf0 x\cb3\cf25 , \cb1\cf0 y\cb3\cf25 ;
\par             \cb1\cf0 MLV_get_mouse_position\cb3\cf25 (&\cb1\cf0 x\cb3\cf25 , &\cb1\cf0 y\cb3\cf25 ); 
\par             \cb1\cf0 MLV_wait_milliseconds\cb3\cf25 (\cb3\cf12 0.01\cb3\cf25 );
\par             \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 MLV_get_mouse_button_state\cb3\cf25 (\cb1\cf0 MLV_BUTTON_LEFT\cb3\cf25 ) == \cb1\cf0 MLV_PRESSED \cb3\cf25 && (\cb1\cf0 isInside\cb3\cf25 (\cb1\cf0 x\cb3\cf25 , \cb1\cf0 y\cb3\cf25 ) == \cb3\cf14\b true\b0\cb3\cf25 )) \{
\par                 \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 MLV_get_mouse_button_state\cb3\cf25 (\cb1\cf0 MLV_BUTTON_LEFT\cb3\cf25 ) == \cb1\cf0 MLV_PRESSED\cb3\cf25 ) \{
\par                     \cb3\cf14\b int \b0\cb1\cf0 x2\cb3\cf25 , \cb1\cf0 y2\cb3\cf25 ;
\par                     \cb1\cf0 MLV_get_mouse_position\cb3\cf25 (&\cb1\cf0 x2\cb3\cf25 , &\cb1\cf0 y2\cb3\cf25 );
\par                     \cb1\cf0 draw\cb3\cf25 (\cb1\cf0 MLV_COLOR_GRAY\cb3\cf25 , \cb1\cf0 MLV_COLOR_GRAY\cb3\cf25 );
\par                     \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par                     \cb3\cf14\b operator\b0\cb3\cf25 ()(\cb1\cf0 x2 \cb3\cf25 - \cb1\cf0 xInside\cb3\cf25 , \cb1\cf0 y2 \cb3\cf25 - \cb1\cf0 yInside\cb3\cf25 );
\par                     \cb1\cf0 MLV_wait_milliseconds\cb3\cf25 (\cb3\cf12 0.01\cb3\cf25 );
\par                     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 MLV_get_mouse_button_state\cb3\cf25 (\cb1\cf0 MLV_BUTTON_RIGHT\cb3\cf25 ) == \cb1\cf0 MLV_PRESSED\cb3\cf25 ) \{
\par                         \cb1\cf0 rotateCenter\cb3\cf25 (\cb3\cf12 1\cb3\cf25 );
\par                         \cb1\cf0 MLV_wait_milliseconds\cb3\cf25 (\cb3\cf12 80\cb3\cf25 ); 
\par                     \}
\par                     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 MLV_get_mouse_button_state\cb3\cf25 (\cb1\cf0 MLV_BUTTON_MIDDLE\cb3\cf25 ) == \cb1\cf0 MLV_PRESSED\cb3\cf25 ) \{
\par                         \cb3\cf16\b reverse\b0\cb3\cf25 ();
\par                     \}
\par                     \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par                     \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 , \cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par                     \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par                     \cb1\cf0 xInside \cb3\cf25 = \cb1\cf0 x2\cb3\cf25 ; 
\par                     \cb1\cf0 yInside \cb3\cf25 = \cb1\cf0 y2\cb3\cf25 ;
\par                 \}
\par             \} 
\par             \cb3\cf14\b else if \b0\cb3\cf25 (\cb1\cf0 MLV_get_mouse_button_state\cb3\cf25 (\cb1\cf0 MLV_BUTTON_LEFT\cb3\cf25 ) == \cb1\cf0 MLV_PRESSED \cb3\cf25 && (\cb1\cf0 isInside\cb3\cf25 (\cb1\cf0 x\cb3\cf25 , \cb1\cf0 y\cb3\cf25 ) == \cb3\cf12 0\cb3\cf25 )) \{
\par                 \cb1\cf0 done \cb3\cf25 = \cb3\cf14\b true\b0\cb3\cf25 ;
\par             \}
\par             \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 MLV_get_mouse_button_state\cb3\cf25 (\cb1\cf0 MLV_BUTTON_RIGHT\cb3\cf25 ) == \cb1\cf0 MLV_PRESSED\cb3\cf25 ) \{
\par                     \cb1\cf0 draw\cb3\cf25 (\cb1\cf0 MLV_COLOR_GRAY\cb3\cf25 , \cb1\cf0 MLV_COLOR_GRAY\cb3\cf25 );
\par                     \cb3\cf14\b int \b0\cb1\cf0 xRot\cb3\cf25 , \cb1\cf0 yRot\cb3\cf25 ;
\par                     \cb1\cf0 MLV_get_mouse_position\cb3\cf25 (&\cb1\cf0 xRot\cb3\cf25 , &\cb1\cf0 yRot\cb3\cf25 );
\par                     \cb3\cf14\b if \b0\cb3\cf25 ((\cb1\cf0 xRot \cb3\cf25 != \cb1\cf0 x\cb3\cf25 ) && (\cb1\cf0 yRot \cb3\cf25 != \cb1\cf0 y\cb3\cf25 )) \{
\par                         \cb1\cf0 rotateCenter\cb3\cf25 (\cb3\cf12 1\cb3\cf25 , \cb1\cf0 xRot\cb3\cf25 , \cb1\cf0 yRot\cb3\cf25 , \cb1\cf0 x\cb3\cf25 , \cb1\cf0 y\cb3\cf25 );
\par                         \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par                         \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 , \cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par                         \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par                         \cb1\cf0 MLV_wait_milliseconds\cb3\cf25 (\cb3\cf12 10\cb3\cf25 );
\par                         \cb1\cf0 x \cb3\cf25 = \cb1\cf0 xRot\cb3\cf25 ;
\par                         \cb1\cf0 y \cb3\cf25 = \cb1\cf0 yRot\cb3\cf25 ;
\par                     \}
\par                 \}
\par             \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 MLV_get_mouse_button_state\cb3\cf25 (\cb1\cf0 MLV_BUTTON_MIDDLE\cb3\cf25 ) == \cb1\cf0 MLV_PRESSED\cb3\cf25 ) \{
\par                 \cb1\cf0 draw\cb3\cf25 (\cb1\cf0 MLV_COLOR_GRAY\cb3\cf25 , \cb1\cf0 MLV_COLOR_GRAY\cb3\cf25 );
\par                 \cb3\cf16\b reverse\b0\cb3\cf25 ();
\par                 \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par                 \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 , \cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par                 \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par             \}
\par             \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 MLV_COLOR_GRAY\cb3\cf25 , \cb1\cf0 MLV_COLOR_GRAY\cb3\cf25 );
\par             \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 MLV_COLOR_GRAY\cb3\cf25 , \cb1\cf0 MLV_COLOR_GRAY\cb3\cf25 );
\par             \cb3\cf14\b for\b0\cb3\cf25 (\cb3\cf14\b auto \b0\cb1\cf0 it \cb3\cf25 : \cb1\cf0 motif\cb3\cf25 )\{
\par                     \cb1\cf0 magnetisme\cb3\cf25 (*\cb1\cf0 it\cb3\cf25 );
\par             \}
\par             \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par             \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 , \cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par         \}
\par         \cb1\cf0 colorfig \cb3\cf25 = \cb1\cf0 colorfig_loc\cb3\cf25 ;
\par         \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par         \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 , \cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par     \}
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 ::\cb1\cf0 display\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 ostream \cb3\cf25 & \cb1\cf0 os\cb3\cf25 ) \cb3\cf14\b const \b0\cb3\cf25 \{
\par     \cb1\cf0 os \cb3\cf25 << \cb3\cf20 " Shape with coordinate : "\cb3\cf25 ;
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b unsigned int \b0\cb1\cf0 i \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i \cb3\cf25 < \cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 (); \cb1\cf0 i\cb3\cf25 ++) \{
\par         \cb1\cf0 os \cb3\cf25 << \cb3\cf20 "[" \cb3\cf25 << \cb1\cf0 px\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] << \cb3\cf20 "; " \cb3\cf25 << \cb1\cf0 py\cb3\cf25 [\cb1\cf0 i\cb3\cf25 ] << \cb3\cf20 "] "\cb3\cf25 ;
\par     \}
\par     \cb1\cf0 os \cb3\cf25 << \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b endl\b0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 saveDraw\cb3\cf25 (\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 fig\cb3\cf25 ) \{
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b ofstream \b0\cb1\cf0 saveFig\cb3\cf25 (\cb3\cf20 "doc/savefig.txt"\cb3\cf25 ,\cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 ios\cb3\cf25 ::\cb1\cf0 app\cb3\cf25 );
\par     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 saveFig\cb3\cf25 ) \{   
\par         \cb3\cf14\b int \b0\cb1\cf0 n \cb3\cf25 = \cb3\cf12 1\cb3\cf25 ;
\par         \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b auto \b0\cb1\cf0 it \cb3\cf25 : \cb1\cf0 fig\cb3\cf25 ) \{
\par             \cb1\cf0 saveFig \cb3\cf25 << \cb1\cf0 n \cb3\cf25 ;
\par             \cb1\cf0 n\cb3\cf25 ++;
\par             \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b unsigned int \b0\cb1\cf0 itp \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 itp \cb3\cf25 < \cb1\cf0 it\cb3\cf25 ->\cb1\cf0 px\cb3\cf25 .\cb3\cf16\b size\b0\cb3\cf25 (); \cb1\cf0 itp\cb3\cf25 ++) \{
\par                 \cb1\cf0 saveFig \cb3\cf25 << \cb3\cf20 " " \cb3\cf25 << \cb1\cf0 it\cb3\cf25 ->\cb1\cf0 px\cb3\cf25 [\cb1\cf0 itp\cb3\cf25 ] << \cb3\cf20 " " \cb3\cf25 << \cb1\cf0 it\cb3\cf25 ->\cb1\cf0 py\cb3\cf25 [\cb1\cf0 itp\cb3\cf25 ] << \cb3\cf20 "  "\cb3\cf25 ;
\par             \}
\par             \cb1\cf0 saveFig \cb3\cf25 << \cb3\cf20 " " \cb3\cf25 << \cb1\cf0 it\cb3\cf25 ->\cb1\cf0 center\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ] << \cb3\cf20 " " \cb3\cf25 << \cb1\cf0 it\cb3\cf25 ->\cb1\cf0 center\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ] << \cb3\cf20 " " \cb3\cf25 << \cb1\cf0 it\cb3\cf25 ->\cb1\cf0 sizeCote \cb3\cf25 << \cb3\cf20 " "\cb3\cf25 ;
\par             \cb1\cf0 saveFig \cb3\cf25 << \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b endl\b0\cb3\cf25 ;
\par         \}
\par         \cb1\cf0 saveFig \cb3\cf25 << \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b endl\b0\cb3\cf25 ;   
\par         \cb1\cf0 saveFig\cb3\cf25 .\cb1\cf0 close\cb3\cf25 ();
\par     \}
\par     \cb3\cf14\b else \b0\cb3\cf25 \{
\par         \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "ERROR: Cannot open savefig.txt." \cb3\cf25 << \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b endl\b0\cb3\cf25 ;
\par     \}
\par \}
\par 
\par \cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 ostream \cb3\cf25 &\cb3\cf14\b operator\b0\cb3\cf25 <<(\cb3\cf16\b std\b0\cb3\cf25 ::\cb1\cf0 ostream \cb3\cf25 &\cb1\cf0 os\cb3\cf25 , \cb3\cf14\b const \b0\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape \cb3\cf25 &\cb1\cf0 tr\cb3\cf25 ) \{
\par     \cb1\cf0 tr\cb3\cf25 .\cb1\cf0 display\cb3\cf25 (\cb1\cf0 os\cb3\cf25 );
\par     \cb3\cf14\b return \b0\cb1\cf0 os\cb3\cf25 ;
\par \}
\par }