{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red200\green200\blue200;\red0\green0\blue0;\red152\green152\blue217;\red192\green192\blue192;\red128\green128\blue255;\red170\green170\blue240;\red0\green128\blue128;\red107\green153\blue153;\red128\green0\blue0;\red172\green89\blue89;\red240\green0\blue240;\red240\green200\blue240;\red0\green0\blue160;\red135\green135\blue200;\red0\green160\blue0;\red154\green200\blue154;\red190\green0\blue190;\red190\green137\blue190;\red0\green0\blue255;\red190\green190\blue255;\red224\green160\blue0;\red224\green206\blue159;\red132\green160\blue132;\red255\green0\blue0;\red255\green200\blue200;\red64\green64\blue128;\red133\green133\blue172;\red128\green255\blue255;\red55\green55\blue55;}
{\info{\comment Generated by the Code::Blocks RTF Exporter plugin}
{\title Untitled}}

\deflang1033\pard\plain\f0\fs20 \cb3\cf16 #include "../include/interface.hpp"
\par #include "../include/rigth_triangle.hpp"
\par #include "../include/square.hpp"
\par #include "../include/parallelogram.hpp"
\par #include "../include/shape.hpp"
\par #include "../include/board.hpp"
\par #include "../include/menu.hpp"
\par #include "../include/button.hpp"
\par 
\par #include <memory> 
\par #include <vector>
\par #include <list>
\par #include <algorithm>
\par #include <cmath>
\par #include <fstream>
\par #include <iostream>
\par #include <string>
\par 
\par \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > \cb1\cf0 figcolor\cb3\cf25 () \{
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > \cb1\cf0 figloc\cb3\cf25 ;
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_GREEN\cb3\cf25 );
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_PINK\cb3\cf25 );
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_ORANGE\cb3\cf25 );
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_BLUE\cb3\cf25 );
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_CYAN\cb3\cf25 );
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_MAGENTA\cb3\cf25 );
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_YELLOW\cb3\cf25 );
\par     \cb3\cf14\b return \b0\cb1\cf0 figloc\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > \cb1\cf0 figWincondition\cb3\cf25 () \{
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > \cb1\cf0 figloc\cb3\cf25 ;
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_GREEN\cb3\cf25 );
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_GREEN\cb3\cf25 );
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_GREEN\cb3\cf25 );
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_GREEN\cb3\cf25 );
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_GREEN\cb3\cf25 );
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_GREEN\cb3\cf25 );
\par     \cb1\cf0 figloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 MLV_COLOR_GREEN\cb3\cf25 );
\par     \cb3\cf14\b return \b0\cb1\cf0 figloc\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 Interface\cb3\cf25 ::\cb1\cf0 initialiseShared\cb3\cf25 (\cb3\cf14\b const int \b0\cb3\cf16\b size\b0\cb3\cf25 ,\cb3\cf14\b const int \b0\cb1\cf0 width\cb3\cf25 ,\cb3\cf14\b const int \b0\cb1\cf0 height\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 shapeShared\cb3\cf25 ) \{
\par     \cb1\cf0 shapeShared\cb3\cf25 .\cb3\cf16\b clear\b0\cb3\cf25 ();
\par     \cb3\cf14\b constexpr int \b0\cb1\cf0 allHeigth \cb3\cf25 = \cb3\cf12 50\cb3\cf25 ;
\par     \cb3\cf14\b constexpr int \b0\cb1\cf0 allWidth \cb3\cf25 = \cb3\cf12 50\cb3\cf25 ;
\par 
\par     \cb3\cf14\b try \b0\cb3\cf25 \{
\par         \cb1\cf0 shapeShared\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Square\cb3\cf25 >(\cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 allWidth \cb3\cf25 + \cb3\cf12 70\cb3\cf25 , \cb1\cf0 allHeigth \cb3\cf25 + \cb3\cf12 100\cb3\cf25 ));
\par         \cb1\cf0 shapeShared\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Parallelogram\cb3\cf25 >(\cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 allWidth \cb3\cf25 + \cb3\cf12 110\cb3\cf25 , \cb1\cf0 allHeigth \cb3\cf25 + \cb3\cf12 500\cb3\cf25 ));
\par         \cb1\cf0 shapeShared\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 RigthTriangle\cb3\cf25 >(\cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 allWidth \cb3\cf25 + \cb3\cf12 70\cb3\cf25 , \cb1\cf0 allHeigth \cb3\cf25 + \cb3\cf12 300\cb3\cf25 ));
\par         \cb1\cf0 shapeShared\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 RigthTriangle\cb3\cf25 >(\cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 allWidth \cb3\cf25 + \cb3\cf12 70\cb3\cf25 , \cb1\cf0 allHeigth \cb3\cf25 + \cb3\cf12 450\cb3\cf25 ));
\par         \cb1\cf0 shapeShared\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 RigthTriangle\cb3\cf25 >(\cb3\cf16\b size \b0\cb3\cf25 * \cb3\cf12 2\cb3\cf25 , \cb1\cf0 allWidth\cb3\cf25 , \cb1\cf0 allHeigth\cb3\cf25 ));
\par         \cb1\cf0 shapeShared\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 RigthTriangle\cb3\cf25 >(\cb3\cf16\b size \b0\cb3\cf25 * \cb3\cf12 2\cb3\cf25 , \cb1\cf0 allWidth\cb3\cf25 , \cb1\cf0 allHeigth \cb3\cf25 + \cb3\cf12 200\cb3\cf25 ));
\par         \cb1\cf0 shapeShared\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 RigthTriangle\cb3\cf25 >(\cb1\cf0 round\cb3\cf25 (\cb3\cf16\b size \b0\cb3\cf25 * \cb1\cf0 sqrt\cb3\cf25 (\cb3\cf12 2\cb3\cf25 )), \cb1\cf0 allWidth\cb3\cf25 , \cb1\cf0 allHeigth \cb3\cf25 + \cb3\cf12 400\cb3\cf25 ));
\par 
\par         \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 shapeShared\cb3\cf25 , \cb1\cf0 figcolor\cb3\cf25 (), \cb1\cf0 MLV_COLOR_RED\cb3\cf25 ); 
\par     \}
\par     \cb3\cf14\b catch \b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b bad_alloc \b0\cb3\cf25 & \cb1\cf0 e\cb3\cf25 ) \{
\par         \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b cerr \b0\cb3\cf25 << \cb3\cf20 "bad_alloc caught: " \cb3\cf25 << \cb1\cf0 e\cb3\cf25 .\cb1\cf0 what\cb3\cf25 () << \cb3\cf22 '\\n'\cb3\cf25 ;
\par         \cb1\cf0 exit\cb3\cf25 (\cb1\cf0 EXIT_FAILURE\cb3\cf25 );
\par     \}
\par     \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par     \cb3\cf14\b return\b0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 Interface\cb3\cf25 ::\cb1\cf0 initialiseMotif\cb3\cf25 (\cb3\cf14\b const int \b0\cb3\cf16\b size\b0\cb3\cf25 ,\cb3\cf14\b const int \b0\cb1\cf0 width\cb3\cf25 ,\cb3\cf14\b const int \b0\cb1\cf0 height\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 motif\cb3\cf25 ) \{
\par     \cb1\cf0 motif\cb3\cf25 .\cb3\cf16\b clear\b0\cb3\cf25 ();
\par     \cb3\cf14\b constexpr int \b0\cb1\cf0 allHeigth \cb3\cf25 = \cb3\cf12 205\cb3\cf25 ;
\par     \cb3\cf14\b constexpr int \b0\cb1\cf0 allWidth \cb3\cf25 = \cb3\cf12 628\cb3\cf25 ;
\par 
\par     \cb3\cf14\b try \b0\cb3\cf25 \{
\par         \cb3\cf4 // Initialisation d'une figure de base - un lapin
\par         \cb1\cf0 motif\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Square\cb3\cf25 >(\cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 allWidth\cb3\cf25 , \cb1\cf0 allHeigth\cb3\cf25 ));
\par         \cb1\cf0 motif\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Parallelogram\cb3\cf25 >(\cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 allWidth \cb3\cf25 + \cb3\cf16\b size \b0\cb3\cf25 * \cb3\cf12 2\cb3\cf25 , \cb1\cf0 allHeigth \cb3\cf25 - \cb3\cf16\b size\b0\cb3\cf25 ));
\par         \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ]->\cb1\cf0 rotateHW\cb3\cf25 (\cb3\cf12 85\cb3\cf25 , \cb3\cf12 3\cb3\cf25 );
\par         \cb1\cf0 motif\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 RigthTriangle\cb3\cf25 >(\cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 allWidth \cb3\cf25 - \cb1\cf0 round\cb3\cf25 (\cb3\cf16\b size \b0\cb3\cf25 / \cb3\cf12 3.3\cb3\cf25 ) - \cb3\cf12 20\cb3\cf25 , \cb1\cf0 allHeigth\cb3\cf25 ));
\par         \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 2\cb3\cf25 ]->\cb1\cf0 rotateHW\cb3\cf25 (-\cb3\cf12 70\cb3\cf25 , \cb3\cf12 1\cb3\cf25 );
\par         \cb1\cf0 motif\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 RigthTriangle\cb3\cf25 >(\cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 allWidth \cb3\cf25 - \cb1\cf0 round\cb3\cf25 (\cb3\cf16\b size \b0\cb3\cf25 / \cb3\cf12 1.45\cb3\cf25 ) - \cb3\cf12 12\cb3\cf25 , \cb1\cf0 allHeigth \cb3\cf25 - \cb1\cf0 round\cb3\cf25 (\cb3\cf16\b size \b0\cb3\cf25 / \cb3\cf12 2.7\cb3\cf25 ) - \cb3\cf12 19\cb3\cf25 ));
\par         \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 3\cb3\cf25 ]->\cb1\cf0 rotateHW\cb3\cf25 (\cb3\cf12 110\cb3\cf25 , \cb3\cf12 0\cb3\cf25 );
\par         \cb1\cf0 motif\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 RigthTriangle\cb3\cf25 >(\cb3\cf16\b size \b0\cb3\cf25 * \cb3\cf12 2\cb3\cf25 , \cb1\cf0 allWidth \cb3\cf25 + \cb1\cf0 round\cb3\cf25 (\cb3\cf16\b size \b0\cb3\cf25 / \cb3\cf12 0.9\cb3\cf25 ) - \cb3\cf12 50\cb3\cf25 , \cb1\cf0 allHeigth \cb3\cf25 + \cb3\cf12 2.98 \cb3\cf25 * \cb3\cf16\b size \b0\cb3\cf25 + \cb3\cf12 2\cb3\cf25 ));
\par         \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 4\cb3\cf25 ]->\cb1\cf0 rotateHW\cb3\cf25 (\cb3\cf12 90\cb3\cf25 , \cb3\cf12 0\cb3\cf25 );
\par         \cb1\cf0 motif\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 RigthTriangle\cb3\cf25 >(\cb3\cf16\b size \b0\cb3\cf25 * \cb3\cf12 2\cb3\cf25 , \cb1\cf0 allWidth \cb3\cf25 + \cb1\cf0 round\cb3\cf25 (\cb3\cf16\b size \b0\cb3\cf25 * \cb3\cf12 3.09\cb3\cf25 ) - \cb3\cf12 47\cb3\cf25 , \cb1\cf0 allHeigth \cb3\cf25 + \cb1\cf0 round\cb3\cf25 (\cb3\cf16\b size \b0\cb3\cf25 * \cb3\cf12 2.62\cb3\cf25 ) + \cb3\cf12 32\cb3\cf25 ));
\par         \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 5\cb3\cf25 ]->\cb1\cf0 rotateHW\cb3\cf25 (-\cb3\cf12 90\cb3\cf25 , \cb3\cf12 0\cb3\cf25 );
\par         \cb1\cf0 motif\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b make_shared\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 RigthTriangle\cb3\cf25 >(\cb1\cf0 round\cb3\cf25 (\cb3\cf16\b size \b0\cb3\cf25 * \cb1\cf0 sqrt\cb3\cf25 (\cb3\cf12 2\cb3\cf25 )), \cb1\cf0 allWidth \cb3\cf25 + \cb1\cf0 round\cb3\cf25 (\cb3\cf16\b size \b0\cb3\cf25 * \cb3\cf12 2.4\cb3\cf25 ) - \cb3\cf12 73\cb3\cf25 , \cb1\cf0 allHeigth \cb3\cf25 + \cb1\cf0 round\cb3\cf25 (\cb3\cf16\b size \b0\cb3\cf25 * \cb3\cf12 3.88\cb3\cf25 ) + \cb3\cf12 10\cb3\cf25 ));
\par         \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 6\cb3\cf25 ]->\cb1\cf0 rotateHW\cb3\cf25 (-\cb3\cf12 45\cb3\cf25 , \cb3\cf12 0\cb3\cf25 );
\par         \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 MLV_COLOR_BLACK\cb3\cf25 , \cb1\cf0 MLV_COLOR_ORANGE\cb3\cf25 ); 
\par     \}
\par     \cb3\cf14\b catch \b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b bad_alloc \b0\cb3\cf25 & \cb1\cf0 e\cb3\cf25 ) \{
\par         \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b cerr \b0\cb3\cf25 << \cb3\cf20 "bad_alloc caught: " \cb3\cf25 << \cb1\cf0 e\cb3\cf25 .\cb1\cf0 what\cb3\cf25 () << \cb3\cf22 '\\n'\cb3\cf25 ;
\par         \cb1\cf0 exit\cb3\cf25 (\cb1\cf0 EXIT_FAILURE\cb3\cf25 );
\par     \}
\par     \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par     \cb3\cf14\b return\b0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 Interface\cb3\cf25 ::\cb1\cf0 clone\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 clone\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 shapeShared\cb3\cf25 ) \{
\par     \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b auto \b0\cb1\cf0 it \cb3\cf25 : \cb1\cf0 shapeShared\cb3\cf25 ) \{
\par         \cb3\cf14\b auto  \b0\cb1\cf0 fig \cb3\cf25 = \cb1\cf0 it\cb3\cf25 ;
\par         \cb1\cf0 clone\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 it\cb3\cf25 );
\par     \}
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 Interface\cb3\cf25 ::\cb3\cf16\b move\b0\cb3\cf25 (\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb3\cf16\b move\b0\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 shapeShared\cb3\cf25 ) \{
\par     \cb3\cf16\b move \b0\cb3\cf25 = \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b move\b0\cb3\cf25 (\cb1\cf0 shapeShared\cb3\cf25 );
\par \}
\par 
\par 
\par \cb3\cf14\b bool \b0\cb1\cf0 Interface\cb3\cf25 ::\cb1\cf0 importDraw \cb3\cf25 (\cb3\cf14\b const int \b0\cb1\cf0 n\cb3\cf25 , \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 motif\cb3\cf25 ) \{
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b ifstream \b0\cb1\cf0 importFig\cb3\cf25 (\cb3\cf20 "doc/savefig.txt"\cb3\cf25 );
\par     \cb3\cf14\b if \b0\cb3\cf25 (!\cb1\cf0 importFig\cb3\cf25 ) \{
\par         \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "ERROR: Cannot open savefig.txt." \cb3\cf25 << \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b endl\b0\cb3\cf25 ;
\par         \cb3\cf14\b return true\b0\cb3\cf25 ;
\par     \}
\par 
\par     \cb3\cf14\b int \b0\cb3\cf16\b count \b0\cb3\cf25 = \cb3\cf12 1\cb3\cf25 ;
\par     \cb3\cf14\b while \b0\cb3\cf25 (\cb3\cf14\b true\b0\cb3\cf25 ) \{
\par         \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 pxloc\cb3\cf25 ;
\par         \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 pyloc\cb3\cf25 ;
\par         \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf14\b double\b0\cb3\cf25 > \cb1\cf0 centloc\cb3\cf25 ;
\par         \cb3\cf14\b double \b0\cb1\cf0 sizeloc\cb3\cf25 ;
\par         \cb3\cf14\b int \b0\cb1\cf0 x\cb3\cf25 ;
\par         \cb3\cf14\b double \b0\cb1\cf0 valx\cb3\cf25 ;
\par         \cb3\cf14\b double \b0\cb1\cf0 valy\cb3\cf25 ;
\par         \cb1\cf0 importFig \cb3\cf25 >> \cb1\cf0 x\cb3\cf25 ;
\par         \cb3\cf14\b int \b0\cb1\cf0 countFig \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ;
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 x \cb3\cf25 > \cb3\cf12 0 \cb3\cf25 && \cb1\cf0 x \cb3\cf25 <= \cb3\cf12 2\cb3\cf25 ) \{
\par             \cb1\cf0 countFig \cb3\cf25 = \cb3\cf12 4\cb3\cf25 ;
\par         \}
\par         \cb3\cf14\b else if \b0\cb3\cf25 (\cb1\cf0 x \cb3\cf25 >= \cb3\cf12 3 \cb3\cf25 && \cb1\cf0 x \cb3\cf25 <= \cb3\cf12 7\cb3\cf25 ) \{
\par             \cb1\cf0 countFig \cb3\cf25 = \cb3\cf12 3\cb3\cf25 ;
\par         \}   
\par         \cb3\cf14\b else \b0\cb3\cf25 \{ 
\par             \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "  Read error "\cb3\cf25 << \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b endl\b0\cb3\cf25 ; 
\par             \cb3\cf14\b return \b0\cb3\cf12 0\cb3\cf25 ;
\par         \}
\par 
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 importFig\cb3\cf25 .\cb1\cf0 eof\cb3\cf25 ()) \{
\par             \cb3\cf14\b return \b0\cb3\cf12 0\cb3\cf25 ;
\par         \}
\par         \cb3\cf14\b for \b0\cb3\cf25 (\cb3\cf14\b int \b0\cb1\cf0 i \cb3\cf25 = \cb3\cf12 0\cb3\cf25 ; \cb1\cf0 i \cb3\cf25 < \cb1\cf0 countFig\cb3\cf25 ; \cb1\cf0 i\cb3\cf25 ++) \{
\par             \cb1\cf0 importFig \cb3\cf25 >> \cb1\cf0 valx\cb3\cf25 ;
\par             \cb1\cf0 importFig \cb3\cf25 >> \cb1\cf0 valy\cb3\cf25 ;
\par             \cb3\cf14\b if \b0\cb3\cf25 (\cb3\cf16\b count \b0\cb3\cf25 == \cb1\cf0 n\cb3\cf25 ) \{
\par                 \cb1\cf0 pxloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 valx\cb3\cf25 );
\par                 \cb1\cf0 pyloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 valy\cb3\cf25 );
\par             \}
\par         \}
\par         \cb1\cf0 importFig \cb3\cf25 >> \cb1\cf0 valx\cb3\cf25 ;
\par         \cb1\cf0 importFig \cb3\cf25 >> \cb1\cf0 valy\cb3\cf25 ;
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb3\cf16\b count \b0\cb3\cf25 == \cb1\cf0 n\cb3\cf25 ) \{
\par             \cb1\cf0 centloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 valx\cb3\cf25 );
\par             \cb1\cf0 centloc\cb3\cf25 .\cb3\cf16\b push_back\b0\cb3\cf25 (\cb1\cf0 valy\cb3\cf25 );
\par         \}
\par         \cb1\cf0 importFig \cb3\cf25 >> \cb1\cf0 valx\cb3\cf25 ;
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb3\cf16\b count \b0\cb3\cf25 == \cb1\cf0 n\cb3\cf25 ) \{
\par             \cb1\cf0 sizeloc \cb3\cf25 = \cb1\cf0 valx\cb3\cf25 ;
\par         \}
\par 
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb3\cf16\b count \b0\cb3\cf25 == \cb1\cf0 n\cb3\cf25 ) \{
\par             \cb3\cf14\b switch\b0\cb3\cf25 (\cb1\cf0 x\cb3\cf25 ) \{
\par                 \cb3\cf14\b case \b0\cb3\cf12 1\cb3\cf25 :
\par                     \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 0\cb3\cf25 ]->\cb1\cf0 setShape\cb3\cf25 (\cb1\cf0 pxloc\cb3\cf25 , \cb1\cf0 pyloc\cb3\cf25 , \cb1\cf0 centloc\cb3\cf25 , \cb1\cf0 sizeloc\cb3\cf25 );
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b case \b0\cb3\cf12 2\cb3\cf25 :
\par                     \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 1\cb3\cf25 ]->\cb1\cf0 setShape\cb3\cf25 (\cb1\cf0 pxloc\cb3\cf25 , \cb1\cf0 pyloc\cb3\cf25 , \cb1\cf0 centloc\cb3\cf25 , \cb1\cf0 sizeloc\cb3\cf25 );
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b case \b0\cb3\cf12 3\cb3\cf25 :
\par                     \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 2\cb3\cf25 ]->\cb1\cf0 setShape\cb3\cf25 (\cb1\cf0 pxloc\cb3\cf25 , \cb1\cf0 pyloc\cb3\cf25 , \cb1\cf0 centloc\cb3\cf25 , \cb1\cf0 sizeloc\cb3\cf25 );
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b case \b0\cb3\cf12 4\cb3\cf25 :
\par                     \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 3\cb3\cf25 ]->\cb1\cf0 setShape\cb3\cf25 (\cb1\cf0 pxloc\cb3\cf25 , \cb1\cf0 pyloc\cb3\cf25 , \cb1\cf0 centloc\cb3\cf25 , \cb1\cf0 sizeloc\cb3\cf25 );
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b case \b0\cb3\cf12 5\cb3\cf25 :
\par                     \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 4\cb3\cf25 ]->\cb1\cf0 setShape\cb3\cf25 (\cb1\cf0 pxloc\cb3\cf25 , \cb1\cf0 pyloc\cb3\cf25 , \cb1\cf0 centloc\cb3\cf25 , \cb1\cf0 sizeloc\cb3\cf25 );
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b case \b0\cb3\cf12 6\cb3\cf25 :
\par                     \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 5\cb3\cf25 ]->\cb1\cf0 setShape\cb3\cf25 (\cb1\cf0 pxloc\cb3\cf25 , \cb1\cf0 pyloc\cb3\cf25 , \cb1\cf0 centloc\cb3\cf25 , \cb1\cf0 sizeloc\cb3\cf25 );
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b case \b0\cb3\cf12 7\cb3\cf25 :
\par                     \cb1\cf0 motif\cb3\cf25 [\cb3\cf12 6\cb3\cf25 ]->\cb1\cf0 setShape\cb3\cf25 (\cb1\cf0 pxloc\cb3\cf25 , \cb1\cf0 pyloc\cb3\cf25 , \cb1\cf0 centloc\cb3\cf25 , \cb1\cf0 sizeloc\cb3\cf25 );
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par             \}
\par         \}
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 x \cb3\cf25 == \cb3\cf12 7 \cb3\cf25 && \cb3\cf16\b count \b0\cb3\cf25 == \cb1\cf0 n\cb3\cf25 ) \{
\par             \cb3\cf14\b break\b0\cb3\cf25 ;
\par         \}
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 x \cb3\cf25 == \cb3\cf12 7\cb3\cf25 ) \{
\par             \cb3\cf16\b count\b0\cb3\cf25 ++; \cb3\cf4 // si on fini un paquet de 7
\par         \cb3\cf25 \}
\par     \}
\par     \cb1\cf0 importFig\cb3\cf25 .\cb1\cf0 close\cb3\cf25 ();
\par     \cb3\cf14\b return true\b0\cb3\cf25 ;
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 Interface\cb3\cf25 ::\cb1\cf0 saveFigure\cb3\cf25 (\cb3\cf14\b const int \b0\cb1\cf0 width\cb3\cf25 ,\cb3\cf14\b const int \b0\cb1\cf0 height\cb3\cf25 ,\cb3\cf14\b const \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> &\cb1\cf0 fig\cb3\cf25 ) \{
\par     \cb1\cf0 MLV_draw_filled_rectangle\cb3\cf25 (\cb1\cf0 round\cb3\cf25 (\cb1\cf0 width \cb3\cf25 / \cb3\cf12 2\cb3\cf25 ) - \cb3\cf12 20\cb3\cf25 , \cb1\cf0 round\cb3\cf25 (\cb1\cf0 height \cb3\cf25 / \cb3\cf12 2\cb3\cf25 ) - \cb3\cf12 20\cb3\cf25 , \cb3\cf12 260\cb3\cf25 , \cb3\cf12 90\cb3\cf25 , \cb1\cf0 MLV_COLOR_DIM_GREY\cb3\cf25 );
\par     \cb1\cf0 MLV_draw_rectangle\cb3\cf25 (\cb1\cf0 round\cb3\cf25 (\cb1\cf0 width \cb3\cf25 / \cb3\cf12 2\cb3\cf25 ) - \cb3\cf12 20\cb3\cf25 , \cb1\cf0 round\cb3\cf25 (\cb1\cf0 height \cb3\cf25 / \cb3\cf12 2\cb3\cf25 ) - \cb3\cf12 20\cb3\cf25 , \cb3\cf12 260\cb3\cf25 , \cb3\cf12 90\cb3\cf25 , \cb1\cf0 MLV_COLOR_BLACK\cb3\cf25 );
\par     
\par     \cb3\cf14\b int \b0\cb1\cf0 interligne \cb3\cf25 = \cb3\cf12 40\cb3\cf25 ;
\par     \cb1\cf0 Button\cb3\cf25 <\cb3\cf14\b int\b0\cb3\cf25 > \cb1\cf0 button1 \cb3\cf25 (\cb1\cf0 round\cb3\cf25 (\cb1\cf0 width \cb3\cf25 / \cb3\cf12 2\cb3\cf25 ), \cb1\cf0 round\cb3\cf25 (\cb1\cf0 height \cb3\cf25 / \cb3\cf12 2\cb3\cf25 ), \cb3\cf12 100\cb3\cf25 , \cb3\cf12 50\cb3\cf25 , \cb3\cf20 "Save"\cb3\cf25 );
\par     \cb1\cf0 Button\cb3\cf25 <\cb3\cf14\b int\b0\cb3\cf25 > \cb1\cf0 button2 \cb3\cf25 (\cb1\cf0 round\cb3\cf25 (\cb1\cf0 width \cb3\cf25 / \cb3\cf12 2\cb3\cf25 ) + \cb3\cf12 120\cb3\cf25 , \cb1\cf0 round\cb3\cf25 (\cb1\cf0 height \cb3\cf25 / \cb3\cf12 2\cb3\cf25 ), \cb3\cf12 100\cb3\cf25 , \cb3\cf12 50\cb3\cf25 , \cb3\cf20 "Cancel"\cb3\cf25 );
\par     \cb1\cf0 button1\cb3\cf25 .\cb1\cf0 drawButton\cb3\cf25 (\cb1\cf0 interligne\cb3\cf25 , \cb1\cf0 MLV_COLOR_GREY\cb3\cf25 , \cb1\cf0 MLV_COLOR_BLACK\cb3\cf25 , \cb1\cf0 MLV_COLOR_WHITE\cb3\cf25 );
\par     \cb1\cf0 button2\cb3\cf25 .\cb1\cf0 drawButton\cb3\cf25 (\cb1\cf0 interligne\cb3\cf25 , \cb1\cf0 MLV_COLOR_GREY\cb3\cf25 , \cb1\cf0 MLV_COLOR_BLACK\cb3\cf25 , \cb1\cf0 MLV_COLOR_WHITE\cb3\cf25 );
\par     \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par 
\par     \cb3\cf14\b int \b0\cb1\cf0 xInside\cb3\cf25 , \cb1\cf0 yInside\cb3\cf25 ;
\par     \cb1\cf0 MLV_wait_mouse\cb3\cf25 (&\cb1\cf0 xInside\cb3\cf25 , &\cb1\cf0 yInside\cb3\cf25 );
\par     \cb3\cf14\b bool \b0\cb1\cf0 save \cb3\cf25 = \cb3\cf14\b true\b0\cb3\cf25 ;
\par     \cb3\cf14\b while \b0\cb3\cf25 (\cb1\cf0 save\cb3\cf25 ) \{
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 button1\cb3\cf25 .\cb1\cf0 inButton\cb3\cf25 (\cb1\cf0 xInside\cb3\cf25 , \cb1\cf0 yInside\cb3\cf25 ))\{
\par             \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "Motif saved" \cb3\cf25 << \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b endl\b0\cb3\cf25 ;
\par             \cb1\cf0 saveDraw\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 );
\par             \cb1\cf0 save \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ;
\par         \}
\par         \cb3\cf14\b else if \b0\cb3\cf25 (\cb1\cf0 button2\cb3\cf25 .\cb1\cf0 inButton\cb3\cf25 (\cb1\cf0 xInside\cb3\cf25 , \cb1\cf0 yInside\cb3\cf25 ))\{
\par             \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b cout \b0\cb3\cf25 << \cb3\cf20 "Cancel" \cb3\cf25 << \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b endl\b0\cb3\cf25 ;
\par             \cb1\cf0 save \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ;
\par         \}
\par         \cb3\cf14\b else \b0\cb3\cf25 \{
\par             \cb1\cf0 MLV_wait_mouse\cb3\cf25 (&\cb1\cf0 xInside\cb3\cf25 , &\cb1\cf0 yInside\cb3\cf25 );
\par         \}
\par     \}
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 Interface\cb3\cf25 ::\cb1\cf0 winner\cb3\cf25 (\cb3\cf14\b const int \b0\cb1\cf0 width\cb3\cf25 ,\cb3\cf14\b const int \b0\cb1\cf0 height\cb3\cf25 ) \{
\par     \cb1\cf0 MLV_Image \cb3\cf25 *\cb1\cf0 image \cb3\cf25 = \cb1\cf0 MLV_load_image\cb3\cf25 (\cb3\cf20 "images/winner.png"\cb3\cf25 );
\par     \cb3\cf14\b int \b0\cb1\cf0 image_width\cb3\cf25 , \cb1\cf0 image_height\cb3\cf25 ;
\par     \cb1\cf0 MLV_get_image_size\cb3\cf25 (\cb1\cf0 image\cb3\cf25 , &\cb1\cf0 image_width\cb3\cf25 , &\cb1\cf0 image_height\cb3\cf25 );
\par     \cb1\cf0 MLV_resize_image_with_proportions\cb3\cf25 (\cb1\cf0 image\cb3\cf25 , \cb1\cf0 image_width \cb3\cf25 * \cb3\cf12 2\cb3\cf25 , \cb1\cf0 image_height \cb3\cf25 * \cb3\cf12 2\cb3\cf25 );
\par     \cb1\cf0 MLV_get_image_size\cb3\cf25 (\cb1\cf0 image\cb3\cf25 , &\cb1\cf0 image_width\cb3\cf25 , &\cb1\cf0 image_height\cb3\cf25 );
\par     \cb3\cf14\b int \b0\cb1\cf0 x_image \cb3\cf25 = -((\cb3\cf12 40 \cb3\cf25 - (\cb1\cf0 width \cb3\cf25 - (\cb1\cf0 round\cb3\cf25 (\cb1\cf0 width \cb3\cf25 / \cb3\cf12 6\cb3\cf25 ) * \cb3\cf12 2\cb3\cf25 ) + \cb3\cf12 150\cb3\cf25 )) / \cb3\cf12 2 \cb3\cf25 + \cb3\cf12 100\cb3\cf25 );
\par     \cb3\cf14\b int \b0\cb1\cf0 y_image \cb3\cf25 = -((\cb3\cf12 30 \cb3\cf25 - (\cb1\cf0 height \cb3\cf25 - (\cb1\cf0 round\cb3\cf25 (\cb1\cf0 height \cb3\cf25 / \cb3\cf12 35\cb3\cf25 ) * \cb3\cf12 2\cb3\cf25 ))) / \cb3\cf12 2 \cb3\cf25 + \cb3\cf12 100\cb3\cf25 );
\par     \cb1\cf0 MLV_draw_image\cb3\cf25 (\cb1\cf0 image\cb3\cf25 , \cb1\cf0 x_image\cb3\cf25 , \cb1\cf0 y_image\cb3\cf25 );
\par     \cb1\cf0 MLV_free_image\cb3\cf25 (\cb1\cf0 image\cb3\cf25 );
\par     \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par \}
\par 
\par \cb3\cf14\b void \b0\cb1\cf0 Interface\cb3\cf25 ::\cb1\cf0 drawJeu\cb3\cf25 (\cb3\cf14\b const int \b0\cb1\cf0 width\cb3\cf25 ,\cb3\cf14\b const int \b0\cb1\cf0 height\cb3\cf25 ) \{
\par     \cb1\cf0 Board board\cb3\cf25 (\cb1\cf0 width\cb3\cf25 , \cb1\cf0 height\cb3\cf25 );
\par     \cb1\cf0 MLV_draw_filled_rectangle\cb3\cf25 (\cb3\cf12 0\cb3\cf25 , \cb3\cf12 0\cb3\cf25 , \cb1\cf0 width\cb3\cf25 , \cb1\cf0 height\cb3\cf25 , \cb1\cf0 MLV_COLOR_BLACK\cb3\cf25 );
\par     \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par     \cb3\cf4 /* Loading contour. */
\par     \cb3\cf14\b int \b0\cb3\cf16\b size \b0\cb3\cf25 = (\cb1\cf0 width \cb3\cf25 + \cb1\cf0 height\cb3\cf25 ) / \cb3\cf12 25\cb3\cf25 ; \cb3\cf4 //100;
\par     \cb1\cf0 MLV_Color motifBorder \cb3\cf25 = \cb1\cf0 MLV_COLOR_BLACK \cb3\cf25 ;
\par     \cb1\cf0 MLV_Color motifShape \cb3\cf25 = \cb1\cf0 MLV_COLOR_BLACK \cb3\cf25 ;
\par     
\par     \cb1\cf0 board\cb3\cf25 .\cb1\cf0 drawBoard\cb3\cf25 ();
\par     \cb1\cf0 board\cb3\cf25 .\cb1\cf0 createButtonForBoard\cb3\cf25 (\cb3\cf12 1\cb3\cf25 );
\par 
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> \cb1\cf0 fig\cb3\cf25 ;
\par     \cb1\cf0 initialiseShared\cb3\cf25 (\cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 width\cb3\cf25 , \cb1\cf0 height\cb3\cf25 , \cb1\cf0 fig\cb3\cf25 );
\par     \cb3\cf6\b /// Utilisation du move sémantic
\par     \b0\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> \cb1\cf0 motif_to_copie\cb3\cf25 ;
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b vector\b0\cb3\cf25 <\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 >> \cb1\cf0 motif\cb3\cf25 ;
\par     \cb1\cf0 initialiseMotif\cb3\cf25 (\cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 width\cb3\cf25 , \cb1\cf0 height\cb3\cf25 , \cb1\cf0 motif_to_copie\cb3\cf25 );
\par     \cb3\cf16\b move\b0\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 ,\cb1\cf0 motif_to_copie\cb3\cf25 );
\par 
\par     \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par     \cb3\cf14\b unsigned int \b0\cb1\cf0 nbFig \cb3\cf25 = \cb3\cf12 1\cb3\cf25 ; \cb3\cf4 // figure motif
\par     \cb3\cf14\b bool \b0\cb1\cf0 contour \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ; 
\par     \cb3\cf14\b bool \b0\cb1\cf0 wincondi \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ;
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > \cb1\cf0 normal_color \cb3\cf25 = \cb1\cf0 figcolor\cb3\cf25 ();
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > \cb1\cf0 win_color \cb3\cf25 = \cb1\cf0 figWincondition\cb3\cf25 ();
\par     \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b list\b0\cb3\cf25 <\cb1\cf0 MLV_Color\cb3\cf25 > \cb1\cf0 colorfig \cb3\cf25 = \cb1\cf0 normal_color\cb3\cf25 ;
\par     \cb3\cf14\b while \b0\cb3\cf25 (\cb3\cf12 1\cb3\cf25 ) \{
\par         \cb3\cf14\b int \b0\cb1\cf0 xInside\cb3\cf25 , \cb1\cf0 yInside\cb3\cf25 ;
\par         \cb1\cf0 MLV_get_mouse_position\cb3\cf25 (&\cb1\cf0 xInside\cb3\cf25 , &\cb1\cf0 yInside\cb3\cf25 );
\par         \cb3\cf14\b auto \b0\cb1\cf0 fig_i \cb3\cf25 = \cb1\cf0 colorfig\cb3\cf25 .\cb3\cf16\b begin\b0\cb3\cf25 ();
\par         \cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b for_each\b0\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 .\cb3\cf16\b begin\b0\cb3\cf25 (), \cb1\cf0 fig\cb3\cf25 .\cb3\cf16\b end\b0\cb3\cf25 (), 
\par             [&](\cb3\cf16\b std\b0\cb3\cf25 ::\cb3\cf16\b shared_ptr\b0\cb3\cf25 <\cb1\cf0 geometricShape\cb3\cf25 ::\cb1\cf0 Shape\cb3\cf25 > \cb1\cf0 it\cb3\cf25 )\{ 
\par             \cb1\cf0 it\cb3\cf25 -> \cb1\cf0 moveShape\cb3\cf25 (\cb1\cf0 xInside\cb3\cf25 , \cb1\cf0 yInside\cb3\cf25 , \cb1\cf0 fig\cb3\cf25 , \cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder \cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 ,\cb1\cf0 fig_i\cb3\cf25 , \cb1\cf0 board\cb3\cf25 ,\cb1\cf0 wincondi\cb3\cf25 );
\par             \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par             \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 , \cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par             \cb1\cf0 fig_i\cb3\cf25 ++;
\par         \});
\par 
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 areEqual\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 fig\cb3\cf25 ) == \cb3\cf12 1 \cb3\cf25 && \cb1\cf0 wincondi \cb3\cf25 == \cb3\cf14\b false\b0\cb3\cf25 ) \{
\par             \cb1\cf0 wincondi \cb3\cf25 = \cb3\cf14\b true\b0\cb3\cf25 ;
\par             \cb1\cf0 colorfig \cb3\cf25 = \cb1\cf0 win_color\cb3\cf25 ;
\par             \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par             \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 , \cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par             \cb1\cf0 winner\cb3\cf25 (\cb1\cf0 width\cb3\cf25 , \cb1\cf0 height\cb3\cf25 ); 
\par         \} 
\par         \cb3\cf14\b else if\b0\cb3\cf25 (\cb1\cf0 wincondi\cb3\cf25 ) \{
\par             \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 areEqual\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 fig\cb3\cf25 ) == \cb3\cf12 0\cb3\cf25 ) \{
\par                 \cb1\cf0 wincondi \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ;
\par                 \cb1\cf0 colorfig \cb3\cf25 = \cb1\cf0 normal_color\cb3\cf25 ;
\par                 \cb1\cf0 board\cb3\cf25 .\cb1\cf0 drawBoard\cb3\cf25 ();
\par                 \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par                 \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 , \cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par             \} \cb3\cf14\b else \b0\cb3\cf25 \{
\par                 \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par                 \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 , \cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par                 \cb1\cf0 winner\cb3\cf25 (\cb1\cf0 width\cb3\cf25 , \cb1\cf0 height\cb3\cf25 ); 
\par             \}
\par         \} 
\par         
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 MLV_get_keyboard_state\cb3\cf25 (\cb1\cf0 MLV_KEYBOARD_LCTRL\cb3\cf25 ) == \cb1\cf0 MLV_PRESSED \cb3\cf25 && \cb1\cf0 MLV_get_keyboard_state\cb3\cf25 (\cb1\cf0 MLV_KEYBOARD_s\cb3\cf25 ) == \cb1\cf0 MLV_PRESSED\cb3\cf25 ) \{
\par             \cb3\cf4 /* Save a polygon for new figure */
\par             \cb1\cf0 saveFigure\cb3\cf25 (\cb1\cf0 width\cb3\cf25 , \cb1\cf0 height\cb3\cf25 , \cb1\cf0 fig\cb3\cf25 );
\par             \cb1\cf0 board\cb3\cf25 .\cb1\cf0 drawBoard\cb3\cf25 ();
\par         \}
\par 
\par         \cb3\cf14\b bool \b0\cb1\cf0 next\cb3\cf25 ;
\par         \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 MLV_get_mouse_button_state\cb3\cf25 (\cb1\cf0 MLV_BUTTON_LEFT\cb3\cf25 ) == \cb1\cf0 MLV_PRESSED\cb3\cf25 ) \{
\par             \cb3\cf14\b int \b0\cb1\cf0 bouton \cb3\cf25 = \cb1\cf0 board\cb3\cf25 .\cb1\cf0 inBoard\cb3\cf25 (\cb1\cf0 xInside\cb3\cf25 , \cb1\cf0 yInside\cb3\cf25 );
\par             \cb3\cf14\b switch \b0\cb3\cf25 (\cb1\cf0 bouton\cb3\cf25 ) \{
\par                 \cb3\cf14\b case \b0\cb3\cf12 0\cb3\cf25 :
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b case \b0\cb3\cf12 1\cb3\cf25 : 
\par                     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 nbFig \cb3\cf25 > \cb3\cf12 0\cb3\cf25 ) \{
\par                         \cb1\cf0 nbFig\cb3\cf25 --;
\par                         \cb1\cf0 board\cb3\cf25 .\cb1\cf0 drawBoard\cb3\cf25 ();
\par                         \cb1\cf0 importDraw\cb3\cf25 (\cb1\cf0 nbFig\cb3\cf25 , \cb1\cf0 motif\cb3\cf25 );
\par                         \cb1\cf0 motifShape \cb3\cf25 = \cb1\cf0 MLV_COLOR_BLACK\cb3\cf25 ;
\par                         \cb1\cf0 motifBorder \cb3\cf25 = \cb1\cf0 MLV_COLOR_BLACK\cb3\cf25 ;
\par                         \cb1\cf0 contour \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ; 
\par                         \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par                         \cb1\cf0 initialiseShared\cb3\cf25 (\cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 width\cb3\cf25 , \cb1\cf0 height\cb3\cf25 , \cb1\cf0 fig\cb3\cf25 );
\par                         \cb1\cf0 colorfig \cb3\cf25 = \cb1\cf0 normal_color\cb3\cf25 ;
\par                         \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 ,\cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par                         \cb1\cf0 board\cb3\cf25 .\cb1\cf0 drawButtonForBoard\cb3\cf25 (\cb1\cf0 nbFig\cb3\cf25 );
\par                         \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par                         \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 MLV_get_mouse_button_state\cb3\cf25 (\cb1\cf0 MLV_BUTTON_LEFT\cb3\cf25 ) != \cb1\cf0 MLV_RELEASED \cb3\cf25 )\{
\par                             \cb1\cf0 MLV_wait_milliseconds\cb3\cf25 (\cb3\cf12 500\cb3\cf25 );
\par                         \}
\par                     \};
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b case \b0\cb3\cf12 2\cb3\cf25 : 
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b case \b0\cb3\cf12 3\cb3\cf25 : 
\par                     \cb1\cf0 nbFig\cb3\cf25 ++;              
\par                     \cb1\cf0 next \cb3\cf25 = \cb1\cf0 importDraw\cb3\cf25 (\cb1\cf0 nbFig\cb3\cf25 , \cb1\cf0 motif\cb3\cf25 );
\par                     \cb3\cf14\b if \b0\cb3\cf25 (\cb1\cf0 next \cb3\cf25 == \cb3\cf14\b false\b0\cb3\cf25 ) \{
\par                         \cb1\cf0 nbFig\cb3\cf25 --;
\par                     \} 
\par                     \cb1\cf0 board\cb3\cf25 .\cb1\cf0 drawBoard\cb3\cf25 ();
\par                     \cb1\cf0 motifShape \cb3\cf25 = \cb1\cf0 MLV_COLOR_BLACK\cb3\cf25 ;
\par                     \cb1\cf0 motifBorder \cb3\cf25 = \cb1\cf0 MLV_COLOR_BLACK\cb3\cf25 ;
\par                     \cb1\cf0 contour \cb3\cf25 = \cb3\cf14\b false\b0\cb3\cf25 ; 
\par                     \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par                     \cb1\cf0 initialiseShared\cb3\cf25 (\cb3\cf16\b size\b0\cb3\cf25 , \cb1\cf0 width\cb3\cf25 , \cb1\cf0 height\cb3\cf25 , \cb1\cf0 fig\cb3\cf25 );
\par                     \cb1\cf0 colorfig \cb3\cf25 = \cb1\cf0 normal_color\cb3\cf25 ;
\par                     \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 , \cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par                     \cb1\cf0 board\cb3\cf25 .\cb1\cf0 drawButtonForBoard\cb3\cf25 (\cb1\cf0 nbFig\cb3\cf25 );
\par                     \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par                     \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 MLV_get_mouse_button_state\cb3\cf25 (\cb1\cf0 MLV_BUTTON_LEFT\cb3\cf25 ) != \cb1\cf0 MLV_RELEASED \cb3\cf25 )\{
\par                         \cb1\cf0 MLV_wait_milliseconds\cb3\cf25 (\cb3\cf12 500\cb3\cf25 );
\par                     \}
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b case \b0\cb3\cf12 4\cb3\cf25 : \cb3\cf4 // Contour
\par                     \cb3\cf14\b if \b0\cb3\cf25 ( \cb1\cf0 contour \cb3\cf25 == \cb3\cf14\b true \b0\cb3\cf25 )\{
\par                         \cb1\cf0 motifBorder \cb3\cf25 = \cb1\cf0 MLV_COLOR_ORANGE\cb3\cf25 ;
\par                     \}
\par                     \cb3\cf14\b else if\b0\cb3\cf25 ( \cb1\cf0 contour \cb3\cf25 == \cb3\cf14\b false\b0\cb3\cf25 )\{
\par                        \cb1\cf0 motifBorder \cb3\cf25 = \cb1\cf0 MLV_COLOR_BLACK\cb3\cf25 ; 
\par                     \}
\par                     \cb1\cf0 contour \cb3\cf25 = !\cb1\cf0 contour\cb3\cf25 ;
\par                     \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 motif\cb3\cf25 , \cb1\cf0 motifShape\cb3\cf25 , \cb1\cf0 motifBorder\cb3\cf25 );
\par                     \cb1\cf0 drawAllShapes\cb3\cf25 (\cb1\cf0 fig\cb3\cf25 , \cb1\cf0 colorfig\cb3\cf25 , \cb1\cf0 MLV_COLOR_RED\cb3\cf25 );
\par                     \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par                     \cb3\cf14\b if\b0\cb3\cf25 (\cb1\cf0 MLV_get_mouse_button_state\cb3\cf25 (\cb1\cf0 MLV_BUTTON_LEFT\cb3\cf25 ) != \cb1\cf0 MLV_RELEASED \cb3\cf25 )\{
\par                         \cb1\cf0 MLV_wait_milliseconds\cb3\cf25 (\cb3\cf12 500\cb3\cf25 );
\par                     \}
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b case \b0\cb3\cf12 5\cb3\cf25 : \cb3\cf4 // Sauvegarder
\par                     \cb1\cf0 saveFigure\cb3\cf25 (\cb1\cf0 width\cb3\cf25 , \cb1\cf0 height\cb3\cf25 , \cb1\cf0 fig\cb3\cf25 );
\par                     \cb1\cf0 board\cb3\cf25 .\cb1\cf0 drawBoard\cb3\cf25 ();
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b case \b0\cb3\cf12 6\cb3\cf25 : \cb3\cf4 // Quitter
\par                     \cb1\cf0 MLV_free_window\cb3\cf25 ();
\par                     \cb1\cf0 exit\cb3\cf25 (\cb1\cf0 EXIT_SUCCESS\cb3\cf25 ); 
\par                     \cb3\cf14\b break\b0\cb3\cf25 ;
\par                 \cb3\cf14\b default\b0\cb3\cf25 : \cb3\cf14\b break\b0\cb3\cf25 ;
\par             \} 
\par         \}
\par         \cb1\cf0 MLV_actualise_window\cb3\cf25 ();
\par     \}
\par \}
\par }